diff -ruN ../src/LoopStrategy.sol LoopStrategy.sol
--- ../src/LoopStrategy.sol	2024-02-01 16:35:01
+++ LoopStrategy.sol	1970-01-01 02:00:00
@@ -1,627 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { ERC4626Upgradeable } from
-    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol";
-import { IPriceOracleGetter } from
-    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
-import { PausableUpgradeable } from
-    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
-import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-import { IERC20Metadata } from
-    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
-import { IPoolAddressesProvider } from
-    "@aave/contracts/interfaces/IPoolAddressesProvider.sol";
-import { IPool } from "@aave/contracts/interfaces/IPool.sol";
-import { ILoopStrategy, IERC4626 } from "./interfaces/ILoopStrategy.sol";
-import { LoanLogic } from "./libraries/LoanLogic.sol";
-import { RebalanceLogic } from "./libraries/RebalanceLogic.sol";
-import { LoopStrategyStorage as Storage } from
-    "./storage/LoopStrategyStorage.sol";
-import {
-    CollateralRatio,
-    LoanState,
-    LendingPool,
-    StrategyAssets
-} from "./types/DataTypes.sol";
-import { ConversionMath } from "./libraries/math/ConversionMath.sol";
-import { RebalanceMath } from "./libraries/math/RebalanceMath.sol";
-import { USDWadRayMath } from "./libraries/math/USDWadRayMath.sol";
-import { SafeERC20 } from
-    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
-import { ISwapper } from "./interfaces/ISwapper.sol";
-import { IWrappedERC20PermissionedDeposit } from
-    "./interfaces/IWrappedERC20PermissionedDeposit.sol";
-import { AccessControlUpgradeable } from
-    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
-import { UUPSUpgradeable } from
-    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
-
-/// @title LoopStrategy
-/// @notice Integrated Liquidity Market strategy for amplifying the cbETH staking rewards
-contract LoopStrategy is
-    ILoopStrategy,
-    ERC4626Upgradeable,
-    AccessControlUpgradeable,
-    PausableUpgradeable,
-    UUPSUpgradeable
-{
-    using USDWadRayMath for uint256;
-
-    /// @dev role which can pause and unpause deposits and withdrawals
-    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
-    /// @dev role which can change strategy parameters
-    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
-    /// @dev role which can upgrade the contract
-    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
-
-    constructor() {
-        _disableInitializers();
-    }
-
-    function LoopStrategy_init(
-        string memory _erc20name,
-        string memory _erc20symbol,
-        address _initialAdmin,
-        StrategyAssets memory _strategyAssets,
-        CollateralRatio memory _collateralRatioTargets,
-        IPoolAddressesProvider _poolAddressProvider,
-        IPriceOracleGetter _oracle,
-        ISwapper _swapper,
-        uint256 _ratioMargin,
-        uint16 _maxIterations
-    ) external initializer {
-        __ERC4626_init(_strategyAssets.underlying);
-        __Pausable_init();
-        __AccessControl_init();
-        __UUPSUpgradeable_init();
-        __ERC20_init(_erc20name, _erc20symbol);
-
-        _grantRole(DEFAULT_ADMIN_ROLE, _initialAdmin);
-
-        Storage.Layout storage $ = Storage.layout();
-        $.assets = _strategyAssets;
-        $.collateralRatioTargets = _collateralRatioTargets;
-        $.poolAddressProvider = _poolAddressProvider;
-        $.oracle = _oracle;
-        $.swapper = _swapper;
-        $.ratioMargin = _ratioMargin;
-        $.maxIterations = _maxIterations;
-
-        $.lendingPool = LendingPool({
-            pool: IPool(_poolAddressProvider.getPool()),
-            // 2 is the variable interest rate mode
-            interestRateMode: 2
-        });
-
-        // there is no assets cap until it's otherwise set by the setter function
-        $.assetsCap = type(uint256).max;
-
-        // approving to lending pool collateral and debt assets in advance
-        $.assets.collateral.approve(
-            address($.lendingPool.pool), type(uint256).max
-        );
-        $.assets.debt.approve(address($.lendingPool.pool), type(uint256).max);
-    }
-
-    /// @inheritdoc UUPSUpgradeable
-    function _authorizeUpgrade(address)
-        internal
-        override
-        onlyRole(UPGRADER_ROLE)
-    { }
-
-    /// @inheritdoc ILoopStrategy
-    function pause() external override onlyRole(PAUSER_ROLE) {
-        _pause();
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function unpause() external override onlyRole(PAUSER_ROLE) {
-        _unpause();
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function setInterestRateMode(uint256 _interestRateMode)
-        external
-        override
-        onlyRole(MANAGER_ROLE)
-    {
-        Storage.layout().lendingPool.interestRateMode = _interestRateMode;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function setCollateralRatioTargets(CollateralRatio memory targets)
-        external
-        override
-        onlyRole(MANAGER_ROLE)
-    {
-        if (
-            targets.minForRebalance > targets.target
-                || targets.maxForRebalance < targets.target
-                || targets.minForRebalance > targets.minForWithdrawRebalance
-                || targets.maxForRebalance < targets.maxForDepositRebalance
-        ) {
-            revert InvalidCollateralRatioTargets();
-        }
-
-        Storage.layout().collateralRatioTargets = targets;
-
-        emit CollateralRatioTargetsSet(targets);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getCollateralRatioTargets()
-        external
-        view
-        override
-        returns (CollateralRatio memory ratio)
-    {
-        return Storage.layout().collateralRatioTargets;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function equityUSD() public view override returns (uint256 amount) {
-        LoanState memory state =
-            LoanLogic.getLoanState(Storage.layout().lendingPool);
-        return state.collateralUSD - state.debtUSD;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function equity() public view override returns (uint256 amount) {
-        return _convertUSDValueToUnderlyingAsset(equityUSD());
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function debt() external view override returns (uint256 amount) {
-        return LoanLogic.getLoanState(Storage.layout().lendingPool).debtUSD;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function collateral() external view override returns (uint256 amount) {
-        return
-            LoanLogic.getLoanState(Storage.layout().lendingPool).collateralUSD;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function currentCollateralRatio()
-        external
-        view
-        override
-        returns (uint256 ratio)
-    {
-        LoanState memory state =
-            LoanLogic.getLoanState(Storage.layout().lendingPool);
-        return
-            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function rebalance()
-        external
-        override
-        whenNotPaused
-        returns (uint256 ratio)
-    {
-        if (!rebalanceNeeded()) {
-            revert RebalanceNotNeeded();
-        }
-        Storage.Layout storage $ = Storage.layout();
-        return RebalanceLogic.rebalanceTo(
-            $,
-            LoanLogic.getLoanState($.lendingPool),
-            $.collateralRatioTargets.target
-        );
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function rebalanceNeeded()
-        public
-        view
-        override
-        returns (bool shouldRebalance)
-    {
-        Storage.Layout storage $ = Storage.layout();
-        LoanState memory state = LoanLogic.getLoanState($.lendingPool);
-        return RebalanceLogic.rebalanceNeeded(
-            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD),
-            $.collateralRatioTargets
-        );
-    }
-
-    /// @inheritdoc IERC4626
-    function totalAssets()
-        public
-        view
-        override(ERC4626Upgradeable, IERC4626)
-        returns (uint256)
-    {
-        return equity();
-    }
-
-    /// @inheritdoc IERC4626
-    function maxDeposit(address)
-        public
-        view
-        override(ERC4626Upgradeable, IERC4626)
-        returns (uint256)
-    {
-        return Storage.layout().assetsCap - totalAssets();
-    }
-
-    /// @inheritdoc IERC4626
-    function deposit(uint256 assets, address receiver)
-        public
-        override(ERC4626Upgradeable, IERC4626)
-        whenNotPaused
-        returns (uint256 shares)
-    {
-        shares = _deposit(assets, receiver, 0);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function deposit(
-        uint256 assets,
-        address receiver,
-        uint256 minSharesReceived
-    ) external override whenNotPaused returns (uint256 shares) {
-        shares = _deposit(assets, receiver, minSharesReceived);
-    }
-
-    /// @inheritdoc IERC4626
-    function previewDeposit(uint256 assets)
-        public
-        view
-        override(ERC4626Upgradeable, IERC4626)
-        returns (uint256)
-    {
-        return _convertToShares(
-            RebalanceLogic.estimateSupply(Storage.layout(), assets),
-            totalAssets()
-        );
-    }
-
-    /// @notice mint function is disabled because we can't get exact amount of input assets for given amount of resulting shares
-    function maxMint(address)
-        public
-        pure
-        override(ERC4626Upgradeable, IERC4626)
-        returns (uint256)
-    {
-        return 0;
-    }
-
-    /// @notice mint function is disabled because we can't get exact amount of input assets for given amount of resulting shares
-    function mint(uint256, address)
-        public
-        view
-        override(ERC4626Upgradeable, IERC4626)
-        whenNotPaused
-        returns (uint256)
-    {
-        revert MintDisabled();
-    }
-
-    /// @notice mint function is disabled because we can't get exact amount of input assets for given amount of resulting shares
-    function previewMint(uint256)
-        public
-        view
-        override(ERC4626Upgradeable, IERC4626)
-        whenNotPaused
-        returns (uint256)
-    {
-        revert MintDisabled();
-    }
-
-    /// @notice withdraw function is disabled because the exact amount of shares for a number of
-    /// tokens cannot be calculated accurately
-    function maxWithdraw(address)
-        public
-        pure
-        override(ERC4626Upgradeable, IERC4626)
-        returns (uint256)
-    {
-        return 0;
-    }
-
-    /// @notice withdraw function is disabled because the exact amount of shares for a number of
-    /// tokens cannot be calculated accurately
-    function withdraw(uint256, address, address)
-        public
-        view
-        override(ERC4626Upgradeable, IERC4626)
-        whenNotPaused
-        returns (uint256)
-    {
-        revert WithdrawDisabled();
-    }
-
-    /// @notice withdraw function is disabled because the exact amount of shares for a number of
-    /// tokens cannot be calculated accurately
-    function previewWithdraw(uint256)
-        public
-        view
-        override(ERC4626Upgradeable, IERC4626)
-        whenNotPaused
-        returns (uint256)
-    {
-        revert WithdrawDisabled();
-    }
-
-    /// @inheritdoc IERC4626
-    function redeem(uint256 shares, address receiver, address owner)
-        public
-        override(ERC4626Upgradeable, IERC4626)
-        whenNotPaused
-        returns (uint256)
-    {
-        return _redeem(shares, receiver, owner, 0);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function redeem(
-        uint256 shares,
-        address receiver,
-        address owner,
-        uint256 minUnderlyingAsset
-    ) external whenNotPaused returns (uint256 assets) {
-        return _redeem(shares, receiver, owner, minUnderlyingAsset);
-    }
-
-    /// @inheritdoc IERC4626
-    function previewRedeem(uint256 shares)
-        public
-        view
-        override(ERC4626Upgradeable, IERC4626)
-        returns (uint256)
-    {
-        return RebalanceLogic.estimateWithdraw(
-            Storage.layout(), shares, totalSupply()
-        );
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function setAssetsCap(uint256 assetsCap) external onlyRole(MANAGER_ROLE) {
-        Storage.layout().assetsCap = assetsCap;
-
-        emit AssetsCapSet(assetsCap);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function setUSDMargin(uint256 marginUSD) external onlyRole(MANAGER_ROLE) {
-        if (marginUSD > USDWadRayMath.USD) {
-            revert MarginOutsideRange();
-        }
-
-        Storage.layout().usdMargin = marginUSD;
-
-        emit USDMarginSet(marginUSD);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function setRatioMargin(uint256 marginUSD)
-        external
-        onlyRole(MANAGER_ROLE)
-    {
-        if (marginUSD > USDWadRayMath.USD) {
-            revert MarginOutsideRange();
-        }
-
-        Storage.layout().ratioMargin = marginUSD;
-
-        emit RatioMarginSet(marginUSD);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function setMaxIterations(uint16 iterations)
-        external
-        onlyRole(MANAGER_ROLE)
-    {
-        Storage.layout().maxIterations = iterations;
-
-        emit MaxIterationsSet(iterations);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function setSwapper(address swapper) external onlyRole(MANAGER_ROLE) {
-        Storage.layout().swapper = ISwapper(swapper);
-
-        emit SwapperSet(swapper);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getAssets() external view returns (StrategyAssets memory assets) {
-        return Storage.layout().assets;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getPoolAddressProvider()
-        external
-        view
-        returns (address poolAddressProvider)
-    {
-        return address(Storage.layout().poolAddressProvider);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getLendingPool() external view returns (LendingPool memory pool) {
-        return Storage.layout().lendingPool;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getOracle() external view returns (address oracle) {
-        return address(Storage.layout().oracle);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getSwapper() external view returns (address swapper) {
-        return address(Storage.layout().swapper);
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getUSDMargin() external view returns (uint256 marginUSD) {
-        return Storage.layout().usdMargin;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getRatioMagin() external view returns (uint256 marginUSD) {
-        return Storage.layout().ratioMargin;
-    }
-
-    /// @inheritdoc ILoopStrategy
-    function getMaxIterations() external view returns (uint256 iterations) {
-        return Storage.layout().maxIterations;
-    }
-
-    /// @notice deposit assets to the strategy with the requirement of equity received after rebalance
-    /// @param assets amount of assets to deposit
-    /// @param receiver address of the receiver of share tokens
-    /// @param minSharesReceived required minimum of equity received
-    /// @return shares number of received shares
-    function _deposit(
-        uint256 assets,
-        address receiver,
-        uint256 minSharesReceived
-    ) internal returns (uint256 shares) {
-        Storage.Layout storage $ = Storage.layout();
-
-        uint256 maxAssets = maxDeposit(receiver);
-        if (assets > maxAssets) {
-            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);
-        }
-
-        SafeERC20.safeTransferFrom(
-            $.assets.underlying, msg.sender, address(this), assets
-        );
-
-        assets = _convertUnderlyingToCollateralAsset($.assets, assets);
-
-        LoanState memory state = RebalanceLogic.updateState($);
-
-        uint256 prevTotalAssets = totalAssets();
-
-        RebalanceLogic.rebalanceAfterSupply($, state, assets);
-
-        uint256 equityReceived = totalAssets() - prevTotalAssets;
-        shares = _convertToShares(equityReceived, prevTotalAssets);
-
-        if (shares < minSharesReceived) {
-            revert SharesReceivedBelowMinimum(shares, minSharesReceived);
-        }
-
-        _mint(receiver, shares);
-
-        emit Deposit(msg.sender, receiver, assets, shares);
-        return shares;
-    }
-
-    /// @notice redeems an amount of shares by burning shares from the owner, and rewarding the receiver with
-    /// the share value
-    /// @param shares amount of shares to burn
-    /// @param receiver address to receive share value
-    /// @param owner address of share owner
-    /// @param minUnderlyingAsset minimum amount of underlying asset to receive
-    /// @return assets amount of underlying asset received
-    function _redeem(
-        uint256 shares,
-        address receiver,
-        address owner,
-        uint256 minUnderlyingAsset
-    ) internal returns (uint256 assets) {
-        Storage.Layout storage $ = Storage.layout();
-
-        uint256 shareUnderlyingAsset = _convertCollateralToUnderlyingAsset(
-            $.assets,
-            RebalanceLogic.rebalanceBeforeWithdraw($, shares, totalSupply())
-        );
-
-        // ensure equity in asset terms to be received is larger than
-        // minimum acceptable amount
-        if (shareUnderlyingAsset < minUnderlyingAsset) {
-            revert UnderlyingReceivedBelowMinimum(
-                shareUnderlyingAsset, minUnderlyingAsset
-            );
-        }
-
-        // burn shares from owner and send corresponding underlying asset ammount to receiver
-        _withdraw(_msgSender(), receiver, owner, shareUnderlyingAsset, shares);
-
-        return shareUnderlyingAsset;
-    }
-
-    /// @notice function is the same formula as in ERC4626 implementation, but totalAssets is passed as a parameter of the function
-    /// @notice we are using this function because totalAssets may change before we are able to calculate asset(equity) amount;
-    /// @notice that is because we are calculating assets based on change in totalAssets
-    /// @param _assets amount of assets provided
-    /// @param _totalAssets amount of total assets which are used in calculation of shares
-    /// @return shares
-    function _convertToShares(uint256 _assets, uint256 _totalAssets)
-        internal
-        view
-        virtual
-        returns (uint256 shares)
-    {
-        shares = Math.mulDiv(
-            _assets,
-            totalSupply() + 10 ** _decimalsOffset(),
-            _totalAssets + 1,
-            Math.Rounding.Floor
-        );
-    }
-
-    /// @notice converts underlying asset to the collateral asset if those are different
-    /// @param assets struct which contain underlying asset address and collateral asset address
-    /// @param collateralAmountAsset amount of collateral to convert
-    /// @return receivedAssets amount of received collateral assets
-    function _convertUnderlyingToCollateralAsset(
-        StrategyAssets storage assets,
-        uint256 collateralAmountAsset
-    ) internal virtual returns (uint256 receivedAssets) {
-        if (assets.underlying != assets.collateral) {
-            assets.underlying.approve(
-                address(assets.collateral), collateralAmountAsset
-            );
-            IWrappedERC20PermissionedDeposit(address(assets.collateral)).deposit(
-                collateralAmountAsset
-            );
-        }
-        receivedAssets = collateralAmountAsset;
-    }
-
-    /// @notice unwrap collateral asset to the underlying asset, if those are different
-    /// @param assets struct which contain underlying asset address and collateral asset address
-    /// @param collateralAmountAsset amount of collateral asset to unwrap
-    /// @return underlyingAmountAsset amount of received underlying assets
-    function _convertCollateralToUnderlyingAsset(
-        StrategyAssets storage assets,
-        uint256 collateralAmountAsset
-    ) internal virtual returns (uint256 underlyingAmountAsset) {
-        if (assets.underlying != assets.collateral) {
-            IWrappedERC20PermissionedDeposit(address(assets.collateral))
-                .withdraw(collateralAmountAsset);
-        }
-        underlyingAmountAsset = collateralAmountAsset;
-    }
-
-    /// @notice converts the USD value to the amount of underlying token assets
-    /// @param usdValue amount of USD to convert
-    function _convertUSDValueToUnderlyingAsset(uint256 usdValue)
-        internal
-        view
-        returns (uint256)
-    {
-        Storage.Layout storage $ = Storage.layout();
-
-        // get underlying price and decimals
-        uint256 underlyingPriceUSD =
-            $.oracle.getAssetPrice(address($.assets.underlying));
-        uint256 underlyingDecimals =
-            IERC20Metadata(address($.assets.underlying)).decimals();
-
-        return ConversionMath.convertUSDToAsset(
-            usdValue, underlyingPriceUSD, underlyingDecimals
-        );
-    }
-}
diff -ruN ../src/interfaces/IAerodromeAdapter.sol interfaces/IAerodromeAdapter.sol
--- ../src/interfaces/IAerodromeAdapter.sol	2024-02-01 16:35:01
+++ interfaces/IAerodromeAdapter.sol	1970-01-01 02:00:00
@@ -1,99 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-import { IRouter } from "../vendor/aerodrome/IRouter.sol";
-
-/// @title IAerodromeAdapter
-/// @notice interface for AerodromeAdapter functionality
-interface IAerodromeAdapter {
-    /// @notice emitted when a value whether a pool is stable or not is set
-    /// @param from first token of the pool
-    /// @param to second token of the pool
-    /// @param status boolean value indicating pool stability
-    event IsPoolStableSet(IERC20 from, IERC20 to, bool status);
-
-    /// @notice emitted when the poolFactory address is set
-    /// @param factory address of poolFactory
-    event PoolFactorySet(address factory);
-
-    /// @notice emitted when the router address is set
-    /// @param router address of router
-    event RouterSet(address router);
-
-    /// @notice emitted when set routes for a given swap are removed
-    /// @param from address to swap from
-    /// @param to addrses to swap to
-    event RoutesRemoved(IERC20 from, IERC20 to);
-
-    /// @notice emitted when the swap routes for a token pair are set
-    /// @param from first token of the pool
-    /// @param to second token of the pool
-    /// @param routes array of routes for swap
-    event RoutesSet(IERC20 from, IERC20 to, IRouter.Route[] routes);
-
-    /// @notice initializing function of adapter
-    /// @param owner address of adapter owner
-    /// @param router address of Aerodrome router
-    /// @param factory address of Aerodrome pair factory
-    /// @param swapper address of swapper
-    function AerodromeAdapter__Init(
-        address owner,
-        address router,
-        address factory,
-        address swapper
-    ) external;
-
-    /// @notice sets the `isPoolStable` boolean for a given pair
-    /// @param from address of first token
-    /// @param to address of second token
-    /// @param status value to set `isPoolStable` to
-    function setIsPoolStable(IERC20 from, IERC20 to, bool status) external;
-
-    /// @notice sets the poolFactory address
-    /// @param factory poolFactory address
-    function setPoolFactory(address factory) external;
-
-    /// @notice sets the router address
-    /// @param router router address
-    function setRouter(address router) external;
-
-    /// @notice sets routes for a given swap
-    /// @param from address of token to swap from
-    /// @param to address of tokent to swap to
-    /// @param routes routes for the swap
-    function setRoutes(IERC20 from, IERC20 to, IRouter.Route[] memory routes)
-        external;
-
-    /// @notice deletes existing routes for a given swap
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    function removeRoutes(IERC20 from, IERC20 to) external;
-
-    /// @notice fetches the 'stable' status of a pool
-    /// @param from address of `from` token
-    /// @param to address of `to` token
-    /// @return status 'stable' status of pool
-    function getIsPoolStable(IERC20 from, IERC20 to)
-        external
-        view
-        returns (bool status);
-
-    /// @notice fetches the Aerodrome PoolFactory address
-    /// @return factory address of Aerodrome PoolFactory contract
-    function getPoolFactory() external view returns (address factory);
-
-    /// @notice fetches the Aerodrome Router address
-    /// @return router address of Aerodrome Router contract
-    function getRouter() external view returns (address router);
-
-    /// @notice fetches the swap routes for a given token swap
-    /// @param from address of `from` token
-    /// @param to address of `to` token
-    /// @return routes IRouter.Route struct array corresponding to the token swap
-    function getSwapRoutes(IERC20 from, IERC20 to)
-        external
-        view
-        returns (IRouter.Route[] memory routes);
-}
diff -ruN ../src/interfaces/ILoopStrategy.sol interfaces/ILoopStrategy.sol
--- ../src/interfaces/ILoopStrategy.sol	2024-02-01 16:35:01
+++ interfaces/ILoopStrategy.sol	1970-01-01 02:00:00
@@ -1,213 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC4626 } from "@openzeppelin/contracts/interfaces/IERC4626.sol";
-import {
-    CollateralRatio,
-    LendingPool,
-    StrategyAssets
-} from "../types/DataTypes.sol";
-
-/// @title IStrategy
-/// @notice interface for Integration Liquiity Market strategies
-/// @dev interface similar to IERC4626, with some additional functions for health management
-interface ILoopStrategy is IERC4626 {
-    /// @notice mint function from IERC4626 is disabled
-    error MintDisabled();
-
-    /// @notice withdraw function from IERC4626 is disabled
-    error WithdrawDisabled();
-
-    /// @notice reverts when rebalance function is called but collateral ratio is in the target range
-    error RebalanceNotNeeded();
-
-    /// @notice reverts when attempting to set collateral ratio targets which are not logically consistent
-    /// in terms of their values
-    error InvalidCollateralRatioTargets();
-
-    /// @notice reverts when shares received by user on deposit is lower than given minimum
-    /// @param sharesReceived amount of shares received
-    /// @param minSharesReceived minimum defined by caller
-    error SharesReceivedBelowMinimum(
-        uint256 sharesReceived, uint256 minSharesReceived
-    );
-
-    /// @notice thrown when underlying received upon share redemption or asset withdrawing is
-    /// less than given minimum limit
-    /// @param underlyingReceived amount of underlying received
-    /// @param minUnderlyingReceived minimum amount of underlying to receive
-    error UnderlyingReceivedBelowMinimum(
-        uint256 underlyingReceived, uint256 minUnderlyingReceived
-    );
-
-    /// @notice thrown when attempting to set a margin value which is meant to lie between
-    /// 0 < margin < 1e8 (1 USD)
-    error MarginOutsideRange();
-
-    /// @notice thrown when the caller of the redeem function is not the owner of the
-    /// shares to be redeemed
-    error RedeemerNotOwner();
-
-    /// @notice emitted when a new value for the collateralRatioTargets is set
-    /// @param targets new value of collateralRatioTargest struct
-    event CollateralRatioTargetsSet(CollateralRatio targets);
-
-    /// @notice emitted when a new value for maxIterations is set
-    /// @param iterations new value for maxIterations
-    event MaxIterationsSet(uint16 iterations);
-
-    /// @notice emitted when a new value for ratioMargin is set
-    /// @param margin new value for ratioMargin
-    event RatioMarginSet(uint256 margin);
-
-    /// @notice emitted when a new value for usdMargin is set
-    /// @param margin new value for usdMargin
-    event USDMarginSet(uint256 margin);
-
-    /// @notice emitted when a new value for assets cap is set
-    /// @param assetsCap new value for assets cap
-    event AssetsCapSet(uint256 assetsCap);
-
-    /// @notice emitted when a new value for the swapper address is set
-    /// @param swapper new address of swapper contract
-    event SwapperSet(address swapper);
-
-    /// @notice returns the amount of equity belonging to the strategy
-    /// in underlying token value
-    /// @return amount equity amount
-    function equity() external view returns (uint256 amount);
-
-    /// @notice returns the amount of equity belonging to the strategy
-    /// in USD value
-    /// @return amount equity amount
-    function equityUSD() external view returns (uint256 amount);
-
-    /// @notice returns the amount of debt belonging to the strategy
-    /// in underlying value (USD)
-    /// @return amount debt amount
-    function debt() external view returns (uint256 amount);
-
-    /// @notice returns the amount of collateral belonging to the strategy
-    /// in underlying value (USD)
-    /// @return amount collateral amount
-    function collateral() external view returns (uint256 amount);
-
-    /// @notice pauses deposits and withdrawals from the contract
-    function pause() external;
-
-    /// @notice unpauses deposits and withdrawals from the contract
-    function unpause() external;
-
-    /// @notice sets the collateral ratio targets (target ratio, min and max for rebalance,
-    /// @notice max for deposit rebalance and min for collateral rebalance)
-    /// @param collateralRatioTargets collateral ratio targets struct
-    function setCollateralRatioTargets(
-        CollateralRatio memory collateralRatioTargets
-    ) external;
-
-    /// @notice returns min, max and target collateral ratio values
-    /// @return ratio struct containing min, max and target collateral ratio values
-    function getCollateralRatioTargets()
-        external
-        view
-        returns (CollateralRatio memory ratio);
-
-    /// @notice sets the interest rate mode for the loan
-    /// @param interestRateMode interest rate mode per aave enum InterestRateMode {NONE, STABLE, VARIABLE}
-    function setInterestRateMode(uint256 interestRateMode) external;
-
-    /// @notice returns the current collateral ratio value of the strategy
-    /// @return ratio current collateral ratio value
-    function currentCollateralRatio() external view returns (uint256 ratio);
-
-    /// @notice rebalances the strategy
-    /// @dev perofrms a downwards/upwards leverage depending on the current strategy state in order to be
-    /// within collateral ratio range
-    /// @return ratio value of collateral ratio after strategy rebalances
-    function rebalance() external returns (uint256 ratio);
-
-    /// @notice retruns true if collateral ratio is out of the target range, and we need to rebalance pool
-    /// @return shouldRebalance true if rebalance is needed
-    function rebalanceNeeded() external view returns (bool shouldRebalance);
-
-    /// @notice deposit assets to the strategy with the requirement of shares received
-    /// @param assets amount of assets to deposit
-    /// @param receiver address of the receiver of share tokens
-    /// @param minSharesReceived required minimum of shares received
-    /// @return shares number of received shares
-    function deposit(
-        uint256 assets,
-        address receiver,
-        uint256 minSharesReceived
-    ) external returns (uint256 shares);
-
-    /// @notice redeems an amount of shares by burning shares from the owner, and rewarding the receiver with
-    /// the share value
-    /// @param shares amount of shares to burn
-    /// @param receiver address to receive share value
-    /// @param owner address of share owner
-    /// @param minUnderlyingAsset minimum amount of underlying asset to receive
-    /// @return assets amount of underlying asset received
-    function redeem(
-        uint256 shares,
-        address receiver,
-        address owner,
-        uint256 minUnderlyingAsset
-    ) external returns (uint256 assets);
-
-    /// @notice sets the assets cap value
-    /// @param assetsCap new value of assets cap
-    function setAssetsCap(uint256 assetsCap) external;
-
-    /// @notice sets the usdMarginUSD value
-    /// @param marginUSD new value of usdMarginUSD
-    function setUSDMargin(uint256 marginUSD) external;
-
-    /// @notice sets the ratioMarginUSD value
-    /// @param marginUSD new value of ratioMarginUSD
-    function setRatioMargin(uint256 marginUSD) external;
-
-    /// @notice sets the maxIterations value
-    /// @param iterations new value of maxIterations
-    function setMaxIterations(uint16 iterations) external;
-
-    /// @notice sets the swapper contract address
-    /// @param swapper address of swapper contract
-    function setSwapper(address swapper) external;
-
-    /// @notice returns underlying StrategyAssets struct
-    /// @return assets underlying StrategyAssets struct
-    function getAssets() external view returns (StrategyAssets memory assets);
-
-    /// @notice returns poolAddressProvider contract address
-    /// @return poolAddressProvider poolAddressProvider contract address
-    function getPoolAddressProvider()
-        external
-        view
-        returns (address poolAddressProvider);
-
-    /// @notice returns LendingPool struct
-    /// @return pool LendingPool struct
-    function getLendingPool() external view returns (LendingPool memory pool);
-
-    /// @notice returns address of oracle contract
-    /// @return oracle address of oracle contract
-    function getOracle() external view returns (address oracle);
-
-    /// @notice returns address of swapper contract
-    /// @return swapper address of swapper contract
-    function getSwapper() external view returns (address swapper);
-
-    /// @notice returns value of usdMargin
-    /// @return marginUSD usdMargin value
-    function getUSDMargin() external view returns (uint256 marginUSD);
-
-    /// @notice returns value of ratioMargin
-    /// @return marginUSD ratioMargin value
-    function getRatioMagin() external view returns (uint256 marginUSD);
-
-    /// @notice returns value of maxIterations
-    /// @return iterations maxIterations value
-    function getMaxIterations() external view returns (uint256 iterations);
-}
diff -ruN ../src/interfaces/IPausable.sol interfaces/IPausable.sol
--- ../src/interfaces/IPausable.sol	2024-02-01 16:35:01
+++ interfaces/IPausable.sol	1970-01-01 02:00:00
@@ -1,20 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-/// @title IPausable
-/// @notice interface for Pausable functionality
-interface IPausable {
-    /// @notice the operation failed because the contract is paused
-    error EnforcedPause();
-
-    /// @notice set paused state to true
-    function pause() external;
-
-    /// @notice set paused state to false
-    function unpause() external view;
-
-    /// @notice returns paused state
-    /// @param state true if paused, false if unpaused
-    function paused() external view returns (bool state);
-}
diff -ruN ../src/interfaces/IPriceOracleGetter.sol interfaces/IPriceOracleGetter.sol
--- ../src/interfaces/IPriceOracleGetter.sol	2024-02-01 16:35:01
+++ interfaces/IPriceOracleGetter.sol	1970-01-01 02:00:00
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: AGPL-3.0
-
-pragma solidity ^0.8.21;
-
-/**
- * @title IPriceOracleGetter
- * @author Aave
- * @notice Interface for the Aave price oracle.
- */
-
-interface IPriceOracleGetter {
-    /**
-     * @notice Returns the base currency address
-     * @dev Address 0x0 is reserved for USD as base currency.
-     * @return Returns the base currency address.
-     */
-    function BASE_CURRENCY() external view returns (address);
-
-    /**
-     * @notice Returns the base currency unit
-     * @dev 1 ether for ETH, 1e8 for USD.
-     * @return Returns the base currency unit.
-     */
-    function BASE_CURRENCY_UNIT() external view returns (uint256);
-
-    /**
-     * @notice Returns the asset price in the base currency
-     * @param asset The address of the asset
-     * @return The price of the asset
-     */
-    function getAssetPrice(address asset) external view returns (uint256);
-}
diff -ruN ../src/interfaces/ISwapAdapter.sol interfaces/ISwapAdapter.sol
--- ../src/interfaces/ISwapAdapter.sol	2024-02-01 16:35:01
+++ interfaces/ISwapAdapter.sol	1970-01-01 02:00:00
@@ -1,42 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-/// @title ISwapAdapter
-/// @notice interface for SwapAdapter contracts
-interface ISwapAdapter {
-    /// @notice thrown when attempting to call Swapper-gated functions
-    error NotSwapper();
-
-    /// @notice emitted when the Swapper contract is set for a given adapter
-    /// @param swapper address of Swapper contract
-    event SwapperSet(address swapper);
-
-    /// @notice swaps a given amount of a token to another token, sending the final amount to the beneficiary
-    /// @dev this is a function that _must_ be implemented by a swap adapter - all DEX-specific logic
-    /// is contained therein
-    /// @param from address of token to swap from
-    /// @param to address of token to swap to
-    /// @param fromAmount amount of from token to swap
-    /// @param beneficiary receiver of final to token amount
-    /// @return toAmount amount of to token returned from swapping
-    function executeSwap(
-        IERC20 from,
-        IERC20 to,
-        uint256 fromAmount,
-        address payable beneficiary
-    ) external returns (uint256 toAmount);
-
-    /// @notice sets the address of the Swapper contract
-    /// @dev this is a function that _must_ be implemented by a swap adapter
-    /// @param swapper address of Swapper contract
-    function setSwapper(address swapper) external;
-
-    /// @notice returns the address of Swapper contract
-    /// @dev this is a function that _must_ be implemented by a swap adapter - permissions
-    /// for calling swaps are granted to this address
-    /// @return swapper address of Swapper contract
-    function getSwapper() external view returns (address swapper);
-}
diff -ruN ../src/interfaces/ISwapper.sol interfaces/ISwapper.sol
--- ../src/interfaces/ISwapper.sol	2024-02-01 16:35:01
+++ interfaces/ISwapper.sol	1970-01-01 02:00:00
@@ -1,135 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IPriceOracleGetter } from
-    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { Step } from "../types/DataTypes.sol";
-
-/// @title ISwapper
-/// @notice interface for Swapper contract
-/// @dev Swapper contract functions as registry and router for Swapper Adapters
-interface ISwapper {
-    /// @notice thrown when attempting to set a USD value which is outside the USD range
-    /// of ONE_USD (1e8)
-    error USDValueOutsideRange();
-
-    /// @notice thrown when attempting to set a maximum acceptable slippage for a given
-    /// token which exceeds ONE_WAD (1e18)
-    error SlippageOutsideRange();
-
-    /// @notice thrown when attempting to set a route which has the zero-address as
-    /// the address of the adapter
-    error InvalidAddress();
-
-    /// @notice thrown when msg.sender attempting to call executeSwap without being part of the
-    /// strategies enumerable set
-    error NotStrategy();
-
-    /// @notice thrown when less tokens than the minimum are returned after a swap
-    error MaxSlippageExceeded();
-
-    /// @notice emitted when a route is set for a given swap
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    /// @param steps array of Step structs needed to perform swap
-    event RouteSet(IERC20 indexed from, IERC20 indexed to, Step[] steps);
-
-    /// @notice emitted when the offsetFactor of a route is set for a given swap
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    /// @param offsetUSD offsetFactor from 0 - 1e8
-    event OffsetFactorSet(
-        IERC20 indexed from, IERC20 indexed to, uint256 offsetUSD
-    );
-
-    /// @notice emitted when the oracle for a given token is set
-    /// @param oracle address of PriceOracleGetter contract
-    event OracleSet(IPriceOracleGetter oracle);
-
-    /// @notice emitted when a new value for the allowed deviation from the offsetFactor
-    /// is set
-    event OffsetDeviationSet(uint256 offsetDeviationUSD);
-
-    /// @notice emitted when a route is removed
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    event RouteRemoved(IERC20 indexed from, IERC20 indexed to);
-
-    /// @notice emitted when a strategy is added to strategies enumerable set
-    /// @param strategy address of added strategy
-    event StrategyAdded(address strategy);
-
-    /// @notice emitted when a strategy is removed from strategies enumerable set
-    /// @param strategy address of added strategy
-    event StrategyRemoved(address strategy);
-
-    /// @notice returns the steps of a swap route
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    /// @return steps array of swap steps needed to end up with `to` token from `from` token
-    function getRoute(IERC20 from, IERC20 to)
-        external
-        returns (Step[] memory steps);
-
-    /// @notice sets the a steps of a swap route
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    /// @param steps  array of swap steps needed to end up with `to` token from `from` token
-    function setRoute(IERC20 from, IERC20 to, Step[] calldata steps) external;
-
-    /// @notice deletes an existing route
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    function removeRoute(IERC20 from, IERC20 to) external;
-
-    /// @notice swaps a given amount of a token to another token, sending the final amount to the beneficiary
-    /// @param from address of token to swap from
-    /// @param to address of token to swap to
-    /// @param fromAmount amount of from token to swap
-    /// @param beneficiary receiver of final to token amount
-    /// @return toAmount amount of to token returned from swapping
-    function swap(
-        IERC20 from,
-        IERC20 to,
-        uint256 fromAmount,
-        address payable beneficiary
-    ) external returns (uint256 toAmount);
-
-    /// @notice calculates the offset factor for the entire swap route from `from` token to `to` token
-    /// @param from address of `from` token
-    /// @param to address of `to` token
-    /// @return offsetUSD factor between 0 - 1e8 to represent offset (1e8 is 100% offset so 0 value returned)
-    function offsetFactor(IERC20 from, IERC20 to)
-        external
-        view
-        returns (uint256 offsetUSD);
-
-    /// @notice sets the offset factor for the entire swap route from `from` token to `to` token
-    /// @param from address of `from` token
-    /// @param to address of `to` token
-    /// @param offsetUSD factor between 0 - 1e8 to represent offset (1e8 is 100% offset so 0 value returned)
-    function setOffsetFactor(IERC20 from, IERC20 to, uint256 offsetUSD)
-        external;
-
-    /// @notice sets a new value for the offsetDeviationUSD from the offsetFactor
-    /// @param offsetDeviationUSD new value for the offsetDeviationUSD
-    function setOffsetDeviationUSD(uint256 offsetDeviationUSD) external;
-
-    /// @notice sets a new address for the oracle
-    /// @param oracle new IPriceOracleGetter contract address
-    function setOracle(IPriceOracleGetter oracle) external;
-
-    /// @notice returns address of oracle contract
-    /// @return oracle address of oracle contract
-    function getOracle() external view returns (IPriceOracleGetter oracle);
-
-    /// @notice returns offsetDeviationUSD value
-    /// @return offsetDeviationUSD offsetDeviationUSD value
-    function getOffsetDeviationUSD()
-        external
-        view
-        returns (uint256 offsetDeviationUSD);
-}
diff -ruN ../src/interfaces/IWrappedERC20PermissionedDeposit.sol interfaces/IWrappedERC20PermissionedDeposit.sol
--- ../src/interfaces/IWrappedERC20PermissionedDeposit.sol	2024-02-01 16:35:01
+++ interfaces/IWrappedERC20PermissionedDeposit.sol	1970-01-01 02:00:00
@@ -1,56 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-/// @title IWrappedERC20PermissionedDeposit
-/// @notice interface for the Wrapper of ERC20 with permissioned deposit
-/// @dev Wraps the underlying ERC20 contract and mints the same amount of a wrapped token.
-/// @dev Deposits are permissioned but withdrawals are open to any address.
-interface IWrappedERC20PermissionedDeposit is IERC20 {
-    /// @notice Sender doesn't have a permission to deposit
-    /// @param sender sender address
-    error NotDepositor(address sender);
-
-    /// @notice Deposit/wrapping underlying token
-    /// @param account account doing the deposit
-    /// @param amount amount of tokens deposited
-    event Deposit(address account, uint256 amount);
-
-    /// @notice Withdraw/unwrapping underlying token
-    /// @param account account doing the withdraw
-    /// @param amount amount of withdrawn tokens
-    event Withdraw(address account, uint256 amount);
-
-    /// @notice Sets deposit permission
-    /// @param account account to set permission for
-    /// @param toSet flag to give/withdraw pemission
-    event SetDepositPermission(address account, bool toSet);
-
-    /// @notice Recovers surplus of underlying token
-    /// @param account account which is doing recovering action
-    /// @param amountSurplus surplus amount recovored
-    event RecoverUnderlyingSurplus(address account, uint256 amountSurplus);
-
-    /// @notice retruns the underlying token address
-    /// @return underlyingToken underlying token
-    function underlying() external view returns (IERC20 underlyingToken);
-
-    /// @notice deposits underlying tokens and mint the same amount of wrapped tokens
-    /// @param amount amount of the tokens to wrap, in wei
-    /// @dev only permissioned depositors are allowed to deposit
-    function deposit(uint256 amount) external;
-
-    /// @notice burns amount of wrapped tokens and recieves back the underlying token
-    /// @param amount amount of the tokens to withdraw, in wei
-    function withdraw(uint256 amount) external;
-
-    /// @notice function used to recover underlying tokens sent directly to this contract by mistake
-    function recover() external;
-
-    /// @notice gives or withdraws permission to deposit
-    /// @param account account address to give/withdraw permission
-    /// @param toSet flag set to true to give permission, or false to withdraw permission
-    function setDepositPermission(address account, bool toSet) external;
-}
diff -ruN ../src/interfaces/IWrappedTokenAdapter.sol interfaces/IWrappedTokenAdapter.sol
--- ../src/interfaces/IWrappedTokenAdapter.sol	2024-02-01 16:35:01
+++ interfaces/IWrappedTokenAdapter.sol	1970-01-01 02:00:00
@@ -1,42 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { IWrappedERC20PermissionedDeposit } from
-    "../interfaces/IWrappedERC20PermissionedDeposit.sol";
-
-/// @title IWrappedTokenAdapter
-/// @notice interface for WrappedTokenAdapter functionality
-interface IWrappedTokenAdapter {
-    /// @notice initializing function of adapter
-    /// @param owner address of adapter owner
-    /// @param swapper address of swapper
-    function WrappedTokenAdapter__Init(address owner, address swapper)
-        external;
-
-    /// @notice sets the wrapper contract for a given token pair
-    /// @param from token to wrap/unwrap
-    /// @param to token received after wrapping/unwrapping
-    /// @param wrapper WrappedERC20PermissionedDeposit contract pertaining to from/to tokens
-    function setWrapper(
-        IERC20 from,
-        IERC20 to,
-        IWrappedERC20PermissionedDeposit wrapper
-    ) external;
-
-    /// @notice removes a previously set wrapper for a given from/to token pair
-    /// @param from token to wrap/unwrap
-    /// @param to token received after wrapping/unwrapping
-    function removeWrapper(IERC20 from, IERC20 to) external;
-
-    /// @notice returns wrapper contract for a given from/to token pair
-    /// @param from token to wrap/unwrap
-    /// @param to token received after wrapping/unwrapping
-    /// @return wrapper WrappedERC20PermissionedDeposit contract pertaining to from/to tokens
-    function getWrapper(IERC20 from, IERC20 to)
-        external
-        view
-        returns (IWrappedERC20PermissionedDeposit wrapper);
-}
diff -ruN ../src/libraries/LoanLogic.sol libraries/LoanLogic.sol
--- ../src/libraries/LoanLogic.sol	2024-02-01 16:35:01
+++ libraries/LoanLogic.sol	1970-01-01 02:00:00
@@ -1,240 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-import { IERC20Metadata } from
-    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
-import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";
-import { IPoolAddressesProvider } from
-    "@aave/contracts/interfaces/IPoolAddressesProvider.sol";
-import { IPool } from "@aave/contracts/interfaces/IPool.sol";
-import { IVariableDebtToken } from
-    "@aave/contracts/interfaces/IVariableDebtToken.sol";
-import { ReserveConfiguration } from
-    "@aave/contracts/protocol/libraries/configuration/ReserveConfiguration.sol";
-import { DataTypes } from
-    "@aave/contracts/protocol/libraries/types/DataTypes.sol";
-import { PercentageMath } from
-    "@aave/contracts/protocol/libraries/math/PercentageMath.sol";
-import { USDWadRayMath } from "./math/USDWadRayMath.sol";
-import { LoanState, LendingPool } from "../types/DataTypes.sol";
-
-/// @title LoanLogic
-/// @notice Contains all logic required for managing the loan position on the Seamless protocol
-/// @dev when calling pool functions, `onBehalfOf` is set to `address(this)` which, in most cases,
-/// @dev represents the strategy vault contract.
-library LoanLogic {
-    using USDWadRayMath for uint256;
-    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
-
-    /// @dev used for availableBorrowsBase and maxWithdrawAmount to decrease them by 0.01%
-    /// @dev because precision issues on converting to asset amounts can revert borrow/withdraw on lending pool
-    uint256 public constant MAX_AMOUNT_PERCENT = 9999;
-
-    /// @notice collateralizes an amount of the given asset via depositing assets into Seamless lending pool
-    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
-    /// @param asset address of collateral asset
-    /// @param amount amount of asset to collateralize
-    /// @return state loan state after supply call
-    function supply(
-        LendingPool memory lendingPool,
-        IERC20 asset,
-        uint256 amount
-    ) external returns (LoanState memory state) {
-        lendingPool.pool.supply(address(asset), amount, address(this), 0);
-        return getLoanState(lendingPool);
-    }
-
-    /// @notice withdraws collateral from the lending pool
-    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
-    /// @param asset address of collateral asset
-    /// @param amount amount of asset to withdraw
-    /// @return state loan state after supply call
-    function withdraw(
-        LendingPool memory lendingPool,
-        IERC20 asset,
-        uint256 amount
-    ) external returns (LoanState memory state) {
-        lendingPool.pool.withdraw(address(asset), amount, address(this));
-        return getLoanState(lendingPool);
-    }
-
-    /// @notice borrows an amount of borrowed asset from the lending pool
-    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
-    /// @param asset address of borrowing asset
-    /// @param amount amount of asset to borrow
-    /// @return state loan state after supply call
-    function borrow(
-        LendingPool memory lendingPool,
-        IERC20 asset,
-        uint256 amount
-    ) external returns (LoanState memory state) {
-        lendingPool.pool.borrow(
-            address(asset),
-            amount,
-            lendingPool.interestRateMode,
-            0,
-            address(this)
-        );
-        return getLoanState(lendingPool);
-    }
-
-    /// @notice repays an amount of borrowed asset to the lending pool
-    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
-    /// @param asset address of borrowing asset
-    /// @param amount amount of borrowing asset to repay
-    /// @return state loan state after supply call
-    function repay(LendingPool memory lendingPool, IERC20 asset, uint256 amount)
-        external
-        returns (LoanState memory state)
-    {
-        lendingPool.pool.repay(
-            address(asset), amount, lendingPool.interestRateMode, address(this)
-        );
-        return getLoanState(lendingPool);
-    }
-
-    /// @notice calculates the debt, and equity corresponding to an amount of shares
-    /// @dev collateral corresponding to shares is just sum of debt and equity
-    /// @param state loan state of strategy
-    /// @param shares amount of shares
-    /// @param totalShares total supply of shares
-    /// @return shareDebtUSD amount of debt in USD corresponding to shares
-    /// @return shareEquityUSD amount of equity in USD corresponding to shares
-    function shareDebtAndEquity(
-        LoanState memory state,
-        uint256 shares,
-        uint256 totalShares
-    ) internal pure returns (uint256 shareDebtUSD, uint256 shareEquityUSD) {
-        // calculate amount of debt and equity corresponding to shares in USD value
-        shareDebtUSD = state.debtUSD.usdMul(
-            USDWadRayMath.wadToUSD(shares.wadDiv(totalShares))
-        );
-        // to calculate equity, first collateral is calculated, and debt is subtracted from it
-        shareEquityUSD = state.collateralUSD.usdMul(
-            USDWadRayMath.wadToUSD(shares.wadDiv(totalShares))
-        ) - shareDebtUSD;
-    }
-
-    /// @notice returns the current state of loan position on the Seamless Protocol lending pool for the caller's account
-    /// @notice all returned values are in USD value
-    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
-    /// @return state loan state after supply call
-    function getLoanState(LendingPool memory lendingPool)
-        internal
-        view
-        returns (LoanState memory state)
-    {
-        (
-            uint256 totalCollateralUSD,
-            uint256 totalDebtUSD,
-            /* availableBorrowsUSD8 */
-            ,
-            uint256 currentLiquidationThreshold,
-            /* ltv */
-            ,
-            /* healthFactor */
-        ) = lendingPool.pool.getUserAccountData(address(this));
-
-        if (totalCollateralUSD == 0) {
-            return LoanState({
-                collateralUSD: 0,
-                debtUSD: 0,
-                maxWithdrawAmount: 0
-            });
-        }
-
-        uint256 maxWithdrawAmount;
-        // This can happen when the debt is already above liquidation trashold
-        // (due to collateral asset price fall, borrow asset price raise, or interest increase)
-        if (
-            totalCollateralUSD
-                < PercentageMath.percentDiv(
-                    totalDebtUSD, currentLiquidationThreshold
-                )
-        ) {
-            maxWithdrawAmount = 0;
-        } else {
-            maxWithdrawAmount = totalCollateralUSD
-                - PercentageMath.percentDiv(
-                    totalDebtUSD, currentLiquidationThreshold
-                );
-        }
-
-        maxWithdrawAmount =
-            PercentageMath.percentMul(maxWithdrawAmount, MAX_AMOUNT_PERCENT);
-
-        return LoanState({
-            collateralUSD: totalCollateralUSD,
-            debtUSD: totalDebtUSD,
-            maxWithdrawAmount: maxWithdrawAmount
-        });
-    }
-
-    /// @notice returns the available supply for the asset, taking into account defined borrow cap
-    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
-    /// @param asset asset for which the available supply is returned
-    /// @return availableAssetSupply available supply
-    function getAvailableAssetSupply(
-        LendingPool memory lendingPool,
-        IERC20 asset
-    ) internal view returns (uint256 availableAssetSupply) {
-        DataTypes.ReserveData memory reserveData =
-            lendingPool.pool.getReserveData(address(asset));
-
-        uint256 totalBorrow = _getTotalBorrow(reserveData);
-        uint256 borrowCap = reserveData.configuration.getBorrowCap();
-        uint256 assetUnit = 10 ** reserveData.configuration.getDecimals();
-        uint256 avilableUntilBorrowCap = (borrowCap * assetUnit > totalBorrow)
-            ? borrowCap * assetUnit - totalBorrow
-            : 0;
-
-        uint256 availableLiquidityBase =
-            asset.balanceOf(reserveData.aTokenAddress);
-
-        availableAssetSupply =
-            Math.min(avilableUntilBorrowCap, availableLiquidityBase);
-        return availableAssetSupply;
-    }
-
-    /// @notice returns the total amount of borrow for given asset reserve data
-    /// @param reserveData reserve data (external type) for the asset
-    /// @return totalBorrow total borrowed amount
-    function _getTotalBorrow(DataTypes.ReserveData memory reserveData)
-        internal
-        view
-        returns (uint256 totalBorrow)
-    {
-        uint256 currScaledVariableDebt = IVariableDebtToken(
-            reserveData.variableDebtTokenAddress
-        ).scaledTotalSupply();
-        totalBorrow =
-            currScaledVariableDebt.rayMul(reserveData.variableBorrowIndex);
-        return totalBorrow;
-    }
-
-    /// @notice returns the maximum borrow avialble for the asset in USD terms, taking into account borrow cap and asset supply
-    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
-    /// @param debtAsset asset for wich max borrow is returned
-    /// @param debtAssetPrice price of the asset
-    /// @return maxBorrowUSD maximum available borrow
-    function getMaxBorrowUSD(
-        LendingPool memory lendingPool,
-        IERC20 debtAsset,
-        uint256 debtAssetPrice
-    ) internal view returns (uint256 maxBorrowUSD) {
-        uint256 availableAssetSupply =
-            getAvailableAssetSupply(lendingPool, debtAsset);
-        uint256 assetDecimals = IERC20Metadata(address(debtAsset)).decimals();
-        uint256 availableAssetSupplyUSD =
-            availableAssetSupply * debtAssetPrice / (10 ** assetDecimals);
-
-        (,, uint256 availableBorrowsUSD,,,) =
-            lendingPool.pool.getUserAccountData(address(this));
-        maxBorrowUSD = Math.min(availableBorrowsUSD, availableAssetSupplyUSD);
-        maxBorrowUSD =
-            PercentageMath.percentMul(maxBorrowUSD, MAX_AMOUNT_PERCENT);
-        return maxBorrowUSD;
-    }
-}
diff -ruN ../src/libraries/RebalanceLogic.sol libraries/RebalanceLogic.sol
--- ../src/libraries/RebalanceLogic.sol	2024-02-15 10:11:42
+++ libraries/RebalanceLogic.sol	1970-01-01 02:00:00
@@ -1,638 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IPriceOracleGetter } from
-    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
-import { IERC20Metadata } from
-    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
-
-import { LoanLogic } from "./LoanLogic.sol";
-import { ConversionMath } from "./math/ConversionMath.sol";
-import { RebalanceMath } from "./math/RebalanceMath.sol";
-import { USDWadRayMath } from "./math/USDWadRayMath.sol";
-import { ISwapper } from "../interfaces/ISwapper.sol";
-import { LoopStrategyStorage as Storage } from
-    "../storage/LoopStrategyStorage.sol";
-import {
-    LendingPool,
-    LoanState,
-    StrategyAssets,
-    CollateralRatio
-} from "../types/DataTypes.sol";
-
-/// @title RebalanceLogic
-/// @notice Contains all logic required for rebalancing
-library RebalanceLogic {
-    using USDWadRayMath for uint256;
-
-    /// @notice thrown when the final ratio after a rebalanceUp operation is outside
-    /// the allowed range
-    error RatioOutsideRange();
-
-    /// @dev ONE in USD scale and in WAD scale
-    uint256 internal constant ONE_USD = 1e8;
-    uint256 internal constant ONE_WAD = USDWadRayMath.WAD;
-
-    /// @dev decimals of USD prices as per _oracle, and WAD decimals
-    uint8 internal constant USD_DECIMALS = 8;
-    uint8 internal constant WAD_DECIMALS = 18;
-
-    /// @notice performs a rebalance operation after supplying an asset amount to the lending pool
-    /// @param $ the storage state of LendingStrategyStorage
-    /// @param state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
-    /// @param assets amount of assets to supply in tokens
-    function rebalanceAfterSupply(
-        Storage.Layout storage $,
-        LoanState memory state,
-        uint256 assets
-    ) external {
-        uint256 prevCollateralRatio =
-            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
-
-        state = LoanLogic.supply($.lendingPool, $.assets.collateral, assets);
-
-        uint256 afterCollateralRatio =
-            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
-
-        if (prevCollateralRatio == type(uint256).max) {
-            rebalanceTo($, state, $.collateralRatioTargets.target);
-        } else if (
-            afterCollateralRatio
-                > $.collateralRatioTargets.maxForDepositRebalance
-        ) {
-            uint256 rebalanceToRatio = prevCollateralRatio;
-            if (
-                $.collateralRatioTargets.maxForDepositRebalance
-                    > rebalanceToRatio
-            ) {
-                rebalanceToRatio =
-                    $.collateralRatioTargets.maxForDepositRebalance;
-            }
-
-            rebalanceTo($, state, rebalanceToRatio);
-        }
-    }
-
-    /// @notice performs a rebalance operation before withdrawing an equity asset amount from the lending pool,
-    /// during a redemption of shares
-    /// @param $ the storage state of LendingStrategyStorage
-    /// @param shares amount of shares to redeem
-    /// @param totalShares total supply of shares
-    /// @return shareEquityAsset amount of equity in asset corresponding to shares
-    function rebalanceBeforeWithdraw(
-        Storage.Layout storage $,
-        uint256 shares,
-        uint256 totalShares
-    ) external returns (uint256 shareEquityAsset) {
-        // get updated loan state
-        LoanState memory state = updateState($);
-
-        // calculate amount of debt and equity corresponding to shares in USD value
-        (uint256 shareDebtUSD, uint256 shareEquityUSD) =
-            LoanLogic.shareDebtAndEquity(state, shares, totalShares);
-
-        // if all shares are being withdrawn, then their debt is the strategy debt
-        // so in that case the redeemer incurs the full cost of paying back the debt
-        // and is left with the remaining equity
-        if (state.debtUSD == shareDebtUSD) {
-            // pay back the debt corresponding to the shares
-            rebalanceDownToDebt($, state, state.debtUSD - shareDebtUSD);
-
-            state = LoanLogic.getLoanState($.lendingPool);
-            shareEquityUSD = state.collateralUSD - state.debtUSD;
-        }
-        //check if withdrawal would lead to a collateral below minimum acceptable level
-        // if yes, rebalance until share debt is repaid, and decrease remaining share equity
-        // by equity cost of rebalance
-        else if (
-            RebalanceMath.collateralRatioUSD(
-                state.collateralUSD - shareEquityUSD, state.debtUSD
-            ) < $.collateralRatioTargets.minForWithdrawRebalance
-        ) {
-            if (
-                state.collateralUSD
-                    > $.collateralRatioTargets.minForWithdrawRebalance.usdMul(
-                        state.debtUSD
-                    )
-            ) {
-                // amount of equity in USD value which may be withdrawn from
-                // strategy without driving the collateral ratio below
-                // the minForWithdrawRebalance limit, thereby not requiring
-                // a rebalance operation
-                uint256 freeEquityUSD = state.collateralUSD
-                    - $.collateralRatioTargets.minForWithdrawRebalance.usdMul(
-                        state.debtUSD
-                    );
-
-                // adjust share debt to account for the free equity - since
-                // some equity may be withdrawn freely, not all the debt has to be
-                // repaid
-                shareDebtUSD = shareDebtUSD
-                    - freeEquityUSD.usdMul(shareDebtUSD).usdDiv(
-                        shareEquityUSD + shareDebtUSD - freeEquityUSD
-                    );
-            }
-
-            uint256 initialEquityUSD = state.collateralUSD - state.debtUSD;
-
-            // pay back the adjusted debt corresponding to the shares
-            rebalanceDownToDebt($, state, state.debtUSD - shareDebtUSD);
-
-            state = LoanLogic.getLoanState($.lendingPool);
-
-            // shares lose equity equal to the amount of equity lost for
-            // the rebalance to pay the adjusted debt
-            if (initialEquityUSD > (state.collateralUSD - state.debtUSD)) {
-                shareEquityUSD -=
-                    initialEquityUSD - (state.collateralUSD - state.debtUSD);
-            }
-        }
-
-        // convert equity to collateral asset
-        shareEquityAsset = ConversionMath.convertUSDToAsset(
-            shareEquityUSD,
-            $.oracle.getAssetPrice(address($.assets.collateral)),
-            IERC20Metadata(address($.assets.collateral)).decimals()
-        );
-
-        // withdraw and transfer equity asset amount
-        LoanLogic.withdraw($.lendingPool, $.assets.collateral, shareEquityAsset);
-    }
-
-    /// @notice performs all operations necessary to rebalance the loan state of the strategy upwards
-    /// @dev note that the current collateral/debt values are expected to be given in underlying value (USD)
-    /// @param $ the storage state of LendingStrategyStorage
-    /// @param state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
-    /// @param targetCR target value of collateral ratio to reach
-    /// @return ratio value of collateral ratio after rebalance
-    function rebalanceTo(
-        Storage.Layout storage $,
-        LoanState memory state,
-        uint256 targetCR
-    ) public returns (uint256 ratio) {
-        // current collateral ratio
-        ratio =
-            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
-
-        if (ratio > targetCR) {
-            return rebalanceUp($, state, ratio, targetCR);
-        } else {
-            return rebalanceDown($, state, ratio, targetCR);
-        }
-    }
-
-    /// @notice performs a rebalance if necessary and returns the updated state after
-    /// the potential rebalance
-    /// @param $ Storage.Layout struct
-    /// @return state current LoanState of strategy
-    function updateState(Storage.Layout storage $)
-        public
-        returns (LoanState memory state)
-    {
-        // get current loan state and calculate initial collateral ratio
-        state = LoanLogic.getLoanState($.lendingPool);
-        uint256 collateralRatio =
-            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
-
-        // if collateralRatio is outside range, user should not incur rebalance costs
-        if (
-            collateralRatio != type(uint256).max
-                && rebalanceNeeded(collateralRatio, $.collateralRatioTargets)
-        ) {
-            rebalanceTo($, state, $.collateralRatioTargets.target);
-
-            state = LoanLogic.getLoanState($.lendingPool);
-        }
-    }
-
-    /// @notice mimics the operations required to supply an asset to the lending pool, estimating
-    /// the overall equity added to the strategy in terms of underlying asset (1e18)
-    /// @param $ Storage.Layout struct
-    /// @param assets amount of collateral asset to be supplied
-    /// @return suppliedEquityAsset esimated amount of equity supplied in asset terms (1e18)
-    function estimateSupply(Storage.Layout storage $, uint256 assets)
-        external
-        view
-        returns (uint256 suppliedEquityAsset)
-    {
-        LoanState memory state = LoanLogic.getLoanState($.lendingPool);
-
-        uint256 currentCR =
-            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
-        uint256 estimateTargetCR;
-
-        uint256 underlyingPriceUSD =
-            $.oracle.getAssetPrice(address($.assets.underlying));
-        uint256 underlyingDecimals =
-            IERC20Metadata(address($.assets.underlying)).decimals();
-
-        uint256 assetsUSD = ConversionMath.convertAssetToUSD(
-            assets,
-            underlyingPriceUSD,
-            IERC20Metadata(address($.assets.underlying)).decimals()
-        );
-
-        if (currentCR == type(uint256).max) {
-            estimateTargetCR = $.collateralRatioTargets.target;
-        } else {
-            if (rebalanceNeeded(currentCR, $.collateralRatioTargets)) {
-                currentCR = $.collateralRatioTargets.target;
-            }
-
-            uint256 afterCR = RebalanceMath.collateralRatioUSD(
-                state.collateralUSD + assetsUSD, state.debtUSD
-            );
-            if (afterCR > $.collateralRatioTargets.maxForDepositRebalance) {
-                estimateTargetCR = currentCR;
-                if (
-                    $.collateralRatioTargets.maxForDepositRebalance
-                        > estimateTargetCR
-                ) {
-                    estimateTargetCR =
-                        $.collateralRatioTargets.maxForDepositRebalance;
-                }
-            } else {
-                estimateTargetCR = afterCR;
-            }
-        }
-
-        uint256 offsetFactor =
-            $.swapper.offsetFactor($.assets.collateral, $.assets.debt);
-        uint256 borrowAmountUSD = RebalanceMath.requiredBorrowUSD(
-            estimateTargetCR, assetsUSD, 0, offsetFactor
-        );
-        uint256 collateralAfterUSD = borrowAmountUSD.usdMul(estimateTargetCR);
-        uint256 estimatedEquityUSD = collateralAfterUSD - borrowAmountUSD;
-
-        return ConversionMath.convertUSDToAsset(
-            estimatedEquityUSD, underlyingPriceUSD, underlyingDecimals
-        );
-    }
-
-    /// @notice mimics the operations required to withdraw an asset from the lending pool, estimating
-    /// the overall equity received from the strategy in terms of underlying asset (1e18)
-    /// @param $ Storage.Layout struct
-    /// @param shares amount of shares to burn to receive equity
-    /// @param totalShares total supply of shares
-    /// @return shareEquityAsset amount of equity assets received for the burnt shares
-    function estimateWithdraw(
-        Storage.Layout storage $,
-        uint256 shares,
-        uint256 totalShares
-    ) external view returns (uint256 shareEquityAsset) {
-        // get current loan state and calculate initial collateral ratio
-        LoanState memory state = LoanLogic.getLoanState($.lendingPool);
-
-        uint256 collateralRatio =
-            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
-
-        // if collateralRatio is outside range, user should not incur rebalance costs
-        if (
-            collateralRatio != type(uint256).max
-                && rebalanceNeeded(collateralRatio, $.collateralRatioTargets)
-        ) {
-            // calculate amount of collateral needed to bring the collateral ratio
-            // to target
-            uint256 neededCollateralUSD = RebalanceMath.requiredCollateralUSD(
-                $.collateralRatioTargets.target,
-                state.collateralUSD,
-                state.debtUSD,
-                $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
-            );
-
-            // calculate new debt and collateral values after collateral has been exchanged
-            // for rebalance
-            state.collateralUSD -= neededCollateralUSD;
-            state.debtUSD -= RebalanceMath.offsetUSDAmountDown(
-                neededCollateralUSD,
-                $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
-            );
-        }
-
-        // calculate amount of debt and equity corresponding to shares in USD value
-        (uint256 shareDebtUSD, uint256 shareEquityUSD) =
-            LoanLogic.shareDebtAndEquity(state, shares, totalShares);
-
-        // case when redeemer is redeeming all remaining shares
-        if (state.debtUSD == shareDebtUSD) {
-            uint256 collateralNeededUSD = shareDebtUSD.usdDiv(
-                USDWadRayMath.USD
-                    - $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
-            );
-
-            shareEquityUSD -= collateralNeededUSD.usdMul(
-                $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
-            );
-        } else if (
-            RebalanceMath.collateralRatioUSD(
-                state.collateralUSD - shareEquityUSD, state.debtUSD
-            ) < $.collateralRatioTargets.minForWithdrawRebalance
-        ) {
-            if (
-                state.collateralUSD
-                    > $.collateralRatioTargets.minForWithdrawRebalance.usdMul(
-                        state.debtUSD
-                    )
-            ) {
-                // amount of equity in USD value which may be withdrawn from
-                // strategy without driving the collateral ratio below
-                // the minForWithdrawRebalance limit, thereby not requiring
-                // a rebalance operation
-                uint256 freeEquityUSD = state.collateralUSD
-                    - $.collateralRatioTargets.minForWithdrawRebalance.usdMul(
-                        state.debtUSD
-                    );
-
-                // adjust share debt to account for the free equity - since
-                // some equity may be withdrawn freely, not all the debt has to be
-                // repaid
-                shareDebtUSD = shareDebtUSD
-                    - freeEquityUSD.usdMul(shareDebtUSD).usdDiv(
-                        shareEquityUSD + shareDebtUSD - freeEquityUSD
-                    );
-            }
-
-            // amount of collateral needed for repaying debt of shares after
-            // freeEquityUSD is accounted for
-            uint256 neededCollateralUSD = shareDebtUSD.usdDiv(
-                USDWadRayMath.USD
-                    - $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
-            );
-
-            shareEquityUSD -= neededCollateralUSD.usdMul(
-                $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
-            );
-        }
-
-        shareEquityAsset = ConversionMath.convertUSDToAsset(
-            shareEquityUSD,
-            $.oracle.getAssetPrice(address($.assets.underlying)),
-            IERC20Metadata(address($.assets.underlying)).decimals()
-        );
-
-        return shareEquityAsset;
-    }
-
-    /// @notice performs all operations necessary to rebalance the loan state of the strategy upwards
-    /// @dev "upwards" in this context means reducing collateral ratio, thereby _increasing_ exposure
-    /// @dev note that the current collateral/debt values are expected to be given in underlying value (USD)
-    /// @param $ the storage state of LendingStrategyStorage
-    /// @param _state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
-    /// @param _currentCR current value of collateral ratio
-    /// @param _targetCR target value of collateral ratio to reach
-    /// @return ratio value of collateral ratio after rebalance
-    function rebalanceUp(
-        Storage.Layout storage $,
-        LoanState memory _state,
-        uint256 _currentCR,
-        uint256 _targetCR
-    ) internal returns (uint256 ratio) {
-        // current collateral ratio
-        ratio = _currentCR;
-
-        uint256 debtPriceUSD = $.oracle.getAssetPrice(address($.assets.debt));
-        uint8 debtDecimals = IERC20Metadata(address($.assets.debt)).decimals();
-
-        // get offset caused by DEX fees + slippage
-        uint256 offsetFactor =
-            $.swapper.offsetFactor($.assets.debt, $.assets.collateral);
-
-        uint256 margin = _targetCR * $.ratioMargin / ONE_USD;
-        uint256 count;
-
-        do {
-            // maximum borrowable amount in USD
-            uint256 borrowAmountUSD = LoanLogic.getMaxBorrowUSD(
-                $.lendingPool,
-                $.assets.debt,
-                $.oracle.getAssetPrice(address($.assets.debt))
-            );
-
-            {
-                // calculate how much borrow amount in USD is needed to reach
-                // targetCR
-                uint256 neededBorrowUSD = RebalanceMath.requiredBorrowUSD(
-                    _targetCR,
-                    _state.collateralUSD,
-                    _state.debtUSD,
-                    offsetFactor
-                );
-
-                // if less than the max borrow amount possible is needed,
-                // use the amount that is required to reach targetCR
-                borrowAmountUSD = borrowAmountUSD < neededBorrowUSD
-                    ? borrowAmountUSD
-                    : neededBorrowUSD;
-            }
-
-            // convert borrowAmount from USD to a borrowAsset amount
-            uint256 borrowAmountAsset = ConversionMath.convertUSDToAsset(
-                borrowAmountUSD, debtPriceUSD, debtDecimals
-            );
-
-            if (borrowAmountAsset == 0) {
-                break;
-            }
-
-            // borrow _assets from lending _pool
-            LoanLogic.borrow($.lendingPool, $.assets.debt, borrowAmountAsset);
-
-            // approve _swapper contract to swap asset
-            $.assets.debt.approve(address($.swapper), borrowAmountAsset);
-
-            // exchange debtAmountAsset of debt tokens for collateral tokens
-            uint256 collateralAmountAsset = $.swapper.swap(
-                $.assets.debt,
-                $.assets.collateral,
-                borrowAmountAsset,
-                payable(address(this))
-            );
-
-            if (collateralAmountAsset == 0) {
-                break;
-            }
-
-            // collateralize _assets in lending _pool
-            _state = LoanLogic.supply(
-                $.lendingPool, $.assets.collateral, collateralAmountAsset
-            );
-
-            // update collateral ratio value
-            ratio = RebalanceMath.collateralRatioUSD(
-                _state.collateralUSD, _state.debtUSD
-            );
-
-            if (++count > $.maxIterations) {
-                break;
-            }
-        } while (_targetCR + margin < ratio);
-
-        // prevent over exposure
-        if (ratio < $.collateralRatioTargets.minForRebalance) {
-            revert RatioOutsideRange();
-        }
-    }
-
-    /// @notice performs all operations necessary to rebalance the loan state of the strategy downwards
-    /// @dev "downards" in this context means increasing collateral ratio, thereby _decreasing_ exposure
-    /// @dev note that the current collateral/debt values are expected to be given in underlying value (USD)
-    /// @param $ the storage state of LendingStrategyStorage
-    /// @param state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
-    /// @param currentCR current value of collateral ratio
-    /// @param targetCR target value of collateral ratio to reach
-    /// @return ratio value of collateral ratio after rebalance
-    function rebalanceDown(
-        Storage.Layout storage $,
-        LoanState memory state,
-        uint256 currentCR,
-        uint256 targetCR
-    ) internal returns (uint256 ratio) {
-        uint256 collateralPriceUSD =
-            $.oracle.getAssetPrice(address($.assets.collateral));
-
-        uint8 collateralDecimals =
-            IERC20Metadata(address($.assets.collateral)).decimals();
-
-        // get offset caused by DEX fees + slippage
-        uint256 offsetFactor =
-            $.swapper.offsetFactor($.assets.collateral, $.assets.debt);
-
-        uint256 margin = targetCR * $.ratioMargin / ONE_USD;
-        uint256 count;
-
-        do {
-            // current collateral ratio
-            ratio = currentCR;
-
-            uint256 collateralAmountAsset = RebalanceMath
-                .calculateCollateralAsset(
-                state,
-                RebalanceMath.requiredCollateralUSD(
-                    targetCR, state.collateralUSD, state.debtUSD, offsetFactor
-                ),
-                collateralPriceUSD,
-                collateralDecimals
-            );
-
-            if (collateralAmountAsset == 0) {
-                break;
-            }
-
-            uint256 borrowAmountAsset =
-                withdrawAndSwapCollateral($, collateralAmountAsset);
-
-            if (borrowAmountAsset == 0) {
-                break;
-            }
-
-            // repay debt to lending _pool
-            state =
-                LoanLogic.repay($.lendingPool, $.assets.debt, borrowAmountAsset);
-
-            // update collateral ratio value
-            ratio = RebalanceMath.collateralRatioUSD(
-                state.collateralUSD, state.debtUSD
-            );
-
-            if (++count > $.maxIterations) {
-                break;
-            }
-        } while (ratio + margin < targetCR);
-    }
-
-    /// @notice rebalances downwards until a debt amount is reached
-    /// @param $ the storage state of LendingStrategyStorage
-    /// @param state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
-    /// @param targetDebtUSD target debt value in USD to reach
-    function rebalanceDownToDebt(
-        Storage.Layout storage $,
-        LoanState memory state,
-        uint256 targetDebtUSD
-    ) internal {
-        uint256 collateralPriceUSD =
-            $.oracle.getAssetPrice(address($.assets.collateral));
-
-        uint8 collateralDecimals =
-            IERC20Metadata(address($.assets.collateral)).decimals();
-
-        // get offset caused by DEX fees + slippage
-        uint256 offsetFactor =
-            $.swapper.offsetFactor($.assets.collateral, $.assets.debt);
-
-        uint256 remainingDebtUSD = state.debtUSD - targetDebtUSD;
-        uint256 count;
-
-        do {
-            uint256 collateralAmountAsset = RebalanceMath
-                .calculateCollateralAsset(
-                state,
-                remainingDebtUSD * ONE_USD / (ONE_USD - offsetFactor),
-                collateralPriceUSD,
-                collateralDecimals
-            );
-
-            if (collateralAmountAsset == 0) {
-                break;
-            }
-
-            uint256 borrowAmountAsset =
-                withdrawAndSwapCollateral($, collateralAmountAsset);
-
-            if (borrowAmountAsset == 0) {
-                break;
-            }
-
-            // repay debt to lending _pool
-            state =
-                LoanLogic.repay($.lendingPool, $.assets.debt, borrowAmountAsset);
-
-            remainingDebtUSD = state.debtUSD > targetDebtUSD
-                ? state.debtUSD - targetDebtUSD
-                : 0;
-
-            if (++count > $.maxIterations) {
-                break;
-            }
-        } while (targetDebtUSD < state.debtUSD);
-    }
-
-    /// @notice withrdraws an amount of collateral asset and exchanges it for an
-    /// amount of debt asset
-    /// @param $ the storage state of LendingStrategyStorage
-    /// @param collateralAmountAsset amount of collateral asset to withdraw and swap
-    /// @return borrowAmountAsset amount of borrow asset received from swap
-    function withdrawAndSwapCollateral(
-        Storage.Layout storage $,
-        uint256 collateralAmountAsset
-    ) internal returns (uint256 borrowAmountAsset) {
-        // withdraw collateral tokens from lending _pool
-        LoanLogic.withdraw(
-            $.lendingPool, $.assets.collateral, collateralAmountAsset
-        );
-
-        // approve swapper contract to swap asset
-        $.assets.collateral.approve(address($.swapper), collateralAmountAsset);
-
-        // exchange collateralAmount of collateral tokens for borrow tokens
-        return $.swapper.swap(
-            $.assets.collateral,
-            $.assets.debt,
-            collateralAmountAsset,
-            payable(address(this))
-        );
-    }
-
-    /// @dev returns if collateral ratio is out of the acceptable range and reabalance should happen
-    /// @param collateralRatio given collateral ratio
-    /// @param collateraRatioTargets struct which contain targets (min and max for rebalance)
-    function rebalanceNeeded(
-        uint256 collateralRatio,
-        CollateralRatio memory collateraRatioTargets
-    ) internal pure returns (bool) {
-        return (
-            collateralRatio < collateraRatioTargets.minForRebalance
-                || collateralRatio > collateraRatioTargets.maxForRebalance
-        );
-    }
-}
diff -ruN ../src/libraries/math/ConversionMath.sol libraries/math/ConversionMath.sol
--- ../src/libraries/math/ConversionMath.sol	2024-02-01 16:35:01
+++ libraries/math/ConversionMath.sol	1970-01-01 02:00:00
@@ -1,42 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { USDWadRayMath } from "./USDWadRayMath.sol";
-
-library ConversionMath {
-    using USDWadRayMath for uint256;
-
-    /// @dev decimals of USD prices as per oracle
-    uint8 internal constant USD_DECIMALS = 8;
-
-    /// @notice converts a asset amount to its usd value
-    /// @param assetAmount amount of asset
-    /// @param priceInUSD price of asset in USD
-    /// @return usdAmount amount of USD after conversion
-    function convertAssetToUSD(
-        uint256 assetAmount,
-        uint256 priceInUSD,
-        uint256 assetDecimals
-    ) internal pure returns (uint256 usdAmount) {
-        usdAmount = assetAmount * priceInUSD / (10 ** assetDecimals);
-    }
-
-    /// @notice converts a USD amount to its token value
-    /// @param usdAmount amount of USD
-    /// @param priceInUSD price of asset in USD
-    /// @return assetAmount amount of asset after conversion
-    function convertUSDToAsset(
-        uint256 usdAmount,
-        uint256 priceInUSD,
-        uint256 assetDecimals
-    ) internal pure returns (uint256 assetAmount) {
-        if (USD_DECIMALS > assetDecimals) {
-            assetAmount = usdAmount.usdDiv(priceInUSD)
-                / (10 ** (USD_DECIMALS - assetDecimals));
-        } else {
-            assetAmount = (usdAmount * (10 ** (assetDecimals - USD_DECIMALS)))
-                .usdDiv(priceInUSD);
-        }
-    }
-}
diff -ruN ../src/libraries/math/RebalanceMath.sol libraries/math/RebalanceMath.sol
--- ../src/libraries/math/RebalanceMath.sol	2024-02-01 16:35:01
+++ libraries/math/RebalanceMath.sol	1970-01-01 02:00:00
@@ -1,108 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { ConversionMath } from "./ConversionMath.sol";
-import { USDWadRayMath } from "./USDWadRayMath.sol";
-import { LoanState } from "../../types/DataTypes.sol";
-
-library RebalanceMath {
-    using USDWadRayMath for uint256;
-
-    uint256 internal constant ONE_USD = 1e8;
-
-    /// @notice helper function to calculate collateral ratio
-    /// @param collateralUSD collateral value in USD
-    /// @param debtUSD debt valut in USD
-    /// @return ratio collateral ratio value
-    function collateralRatioUSD(uint256 collateralUSD, uint256 debtUSD)
-        internal
-        pure
-        returns (uint256 ratio)
-    {
-        ratio = debtUSD != 0 ? collateralUSD.usdDiv(debtUSD) : type(uint256).max;
-    }
-
-    /// @notice helper function to offset amounts by a USD percentage downwards
-    /// @param a amount to offset
-    /// @param offsetUSD offset as a number between 0 -  ONE_USD
-    function offsetUSDAmountDown(uint256 a, uint256 offsetUSD)
-        internal
-        pure
-        returns (uint256 amount)
-    {
-        // prevent overflows
-        if (a <= type(uint256).max / (ONE_USD - offsetUSD)) {
-            amount = (a * (ONE_USD - offsetUSD)) / ONE_USD;
-        } else {
-            amount = (a / ONE_USD) * (ONE_USD - offsetUSD);
-        }
-    }
-
-    /// @notice calculates the total required borrow amount in order to reach a target collateral ratio value
-    /// @param targetCR target collateral ratio value
-    /// @param collateralUSD current collateral value in USD
-    /// @param debtUSD current debt value in USD
-    /// @param offsetFactor expected loss to DEX fees and slippage expressed as a value from 0 - ONE_USD
-    /// @return amount required borrow amount
-    function requiredBorrowUSD(
-        uint256 targetCR,
-        uint256 collateralUSD,
-        uint256 debtUSD,
-        uint256 offsetFactor
-    ) internal pure returns (uint256 amount) {
-        return (collateralUSD - targetCR.usdMul(debtUSD)).usdDiv(
-            targetCR - (ONE_USD - offsetFactor)
-        );
-    }
-
-    /// @notice calculates the total required collateral amount in order to reach a target collateral ratio value
-    /// @param targetCR target collateral ratio value
-    /// @param collateralUSD current collateral value in USD
-    /// @param debtUSD current debt value in USD
-    /// @param offsetFactor expected loss to DEX fees and slippage expressed as a value from 0 - ONE_USD
-    /// @return amount required collateral amount
-    function requiredCollateralUSD(
-        uint256 targetCR,
-        uint256 collateralUSD,
-        uint256 debtUSD,
-        uint256 offsetFactor
-    ) internal pure returns (uint256 amount) {
-        return (
-            amount = (targetCR.usdMul(debtUSD) - collateralUSD).usdDiv(
-                targetCR.usdMul(ONE_USD - offsetFactor) - ONE_USD
-            )
-        );
-    }
-
-    /// @notice determines the collateral asset amount needed for a rebalance down cycle
-    /// @param state loan state
-    /// @param neededCollateralUSD collateral needed for overall operation in USD
-    /// @param collateralPriceUSD price of collateral in USD
-    /// @param collateralDecimals decimals of collateral token
-    /// @return collateralAmountAsset amount of collateral asset needed fo the current rebalance down cycle
-    function calculateCollateralAsset(
-        LoanState memory state,
-        uint256 neededCollateralUSD,
-        uint256 collateralPriceUSD,
-        uint256 collateralDecimals
-    ) internal pure returns (uint256 collateralAmountAsset) {
-        // maximum amount of collateral to not jeopardize loan health in USD
-        uint256 collateralAmountUSD = state.maxWithdrawAmount;
-
-        // handle cases where debt is less than maxWithdrawAmount possible
-        if (state.debtUSD < state.maxWithdrawAmount) {
-            collateralAmountUSD = state.debtUSD;
-        }
-
-        // if less than the max collateral amount possible is needed,
-        // use the amount that is required to reach targetCR
-        collateralAmountUSD = collateralAmountUSD < neededCollateralUSD
-            ? collateralAmountUSD
-            : neededCollateralUSD;
-
-        return ConversionMath.convertUSDToAsset(
-            collateralAmountUSD, collateralPriceUSD, collateralDecimals
-        );
-    }
-}
diff -ruN ../src/libraries/math/USDWadRayMath.sol libraries/math/USDWadRayMath.sol
--- ../src/libraries/math/USDWadRayMath.sol	2024-02-04 09:44:15
+++ libraries/math/USDWadRayMath.sol	1970-01-01 02:00:00
@@ -1,204 +0,0 @@
-// SPDX-License-Identifier: MIT
-
-pragma solidity ^0.8.21;
-
-/**
- * @title WadRayMath library
- * @author Aave
- * @notice Provides functions to perform calculations with Wad and Ray units
- * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers
- * with 27 digits of precision), and USDs (decimal numbers with 8 digits of precisions)
- * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.
- * @dev USD-related functionality added by Seamless
- */
-library USDWadRayMath {
-    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly
-    uint256 internal constant WAD = 1e18;
-    uint256 internal constant HALF_WAD = 0.5e18;
-
-    uint256 internal constant RAY = 1e27;
-    uint256 internal constant HALF_RAY = 0.5e27;
-
-    uint256 internal constant USD = 1e8;
-    uint256 internal constant HALF_USD = 0.5e8;
-
-    uint256 internal constant USD_WAD_RATIO = 1e10;
-    uint256 internal constant WAD_RAY_RATIO = 1e9;
-
-    /**
-     * @dev Multiplies two wad, rounding half up to the nearest wad
-     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-     * @param a Wad
-     * @param b Wad
-     * @return c = a*b, in wad
-     */
-    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
-        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b
-        assembly {
-            if iszero(
-                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))
-            ) { revert(0, 0) }
-
-            c := div(add(mul(a, b), HALF_WAD), WAD)
-        }
-    }
-
-    /// @dev Divides two USD, rounding half up to the nearest USD
-    /// @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-    /// @param a USD
-    /// @param b USD
-    /// @return c = a/b, in USD
-    function usdDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
-        // to avoid overflow, a <= (type(uint256).max - halfB) / USD
-        assembly {
-            if or(
-                iszero(b),
-                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), USD))))
-            ) { revert(0, 0) }
-
-            c := div(add(mul(a, USD), div(b, 2)), b)
-        }
-    }
-
-    function usdDivRoundDown(uint256 a, uint256 b)
-        internal
-        pure
-        returns (uint256 c)
-    {
-        // to avoid overflow, a <= (type(uint256).max - halfB) / USD
-        assembly {
-            if or(
-                iszero(b),
-                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), USD))))
-            ) { revert(0, 0) }
-
-            c := div(mul(a, USD), b)
-        }
-    }
-
-    /// @dev Multiplies two USD, rounding half up to the nearest USD
-    /// @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-    /// @param a USD
-    /// @param b USD
-    /// @return c = a*b, in USD
-    function usdMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
-        // to avoid overflow, a <= (type(uint256).max - HALF_USD) / b
-        assembly {
-            if iszero(
-                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_USD), b))))
-            ) { revert(0, 0) }
-
-            c := div(add(mul(a, b), HALF_USD), USD)
-        }
-    }
-
-    /**
-     * @dev Divides two wad, rounding half up to the nearest wad
-     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-     * @param a Wad
-     * @param b Wad
-     * @return c = a/b, in wad
-     */
-    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
-        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD
-        assembly {
-            if or(
-                iszero(b),
-                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))
-            ) { revert(0, 0) }
-
-            c := div(add(mul(a, WAD), div(b, 2)), b)
-        }
-    }
-
-    /**
-     * @notice Multiplies two ray, rounding half up to the nearest ray
-     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-     * @param a Ray
-     * @param b Ray
-     * @return c = a raymul b
-     */
-    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
-        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b
-        assembly {
-            if iszero(
-                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))
-            ) { revert(0, 0) }
-
-            c := div(add(mul(a, b), HALF_RAY), RAY)
-        }
-    }
-
-    /**
-     * @notice Divides two ray, rounding half up to the nearest ray
-     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-     * @param a Ray
-     * @param b Ray
-     * @return c = a raydiv b
-     */
-    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
-        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY
-        assembly {
-            if or(
-                iszero(b),
-                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))
-            ) { revert(0, 0) }
-
-            c := div(add(mul(a, RAY), div(b, 2)), b)
-        }
-    }
-
-    /**
-     * @dev Casts ray down to wad
-     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-     * @param a Ray
-     * @return b = a converted to wad, rounded half up to the nearest wad
-     */
-    function rayToWad(uint256 a) internal pure returns (uint256 b) {
-        assembly {
-            b := div(a, WAD_RAY_RATIO)
-            let remainder := mod(a, WAD_RAY_RATIO)
-            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) { b := add(b, 1) }
-        }
-    }
-
-    /**
-     * @dev Converts wad up to ray
-     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-     * @param a Wad
-     * @return b = a converted in ray
-     */
-    function wadToRay(uint256 a) internal pure returns (uint256 b) {
-        // to avoid overflow, b/WAD_RAY_RATIO == a
-        assembly {
-            b := mul(a, WAD_RAY_RATIO)
-
-            if iszero(eq(div(b, WAD_RAY_RATIO), a)) { revert(0, 0) }
-        }
-    }
-
-    /// @dev Casts wad down to USD
-    /// @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-    /// @param a Wad
-    /// @return b = a converted to USD, rounded half up to the nearest USD
-    function wadToUSD(uint256 a) internal pure returns (uint256 b) {
-        assembly {
-            b := div(a, USD_WAD_RATIO)
-            let remainder := mod(a, USD_WAD_RATIO)
-            if iszero(lt(remainder, div(USD_WAD_RATIO, 2))) { b := add(b, 1) }
-        }
-    }
-
-    /// @dev Converts USD up to Wad
-    /// @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
-    /// @param a USD
-    /// @return b = a converted in wad
-    function usdToWad(uint256 a) internal pure returns (uint256 b) {
-        // to avoid overflow, b/USD_WAD_RATIO == a
-        assembly {
-            b := mul(a, USD_WAD_RATIO)
-
-            if iszero(eq(div(b, USD_WAD_RATIO), a)) { revert(0, 0) }
-        }
-    }
-}
diff -ruN ../src/src/LoopStrategy.sol src/LoopStrategy.sol
--- ../src/src/LoopStrategy.sol	1970-01-01 02:00:00
+++ src/LoopStrategy.sol	2024-02-13 01:00:56
@@ -0,0 +1,627 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { ERC4626Upgradeable } from
+    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC4626Upgradeable.sol";
+import { IPriceOracleGetter } from
+    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
+import { PausableUpgradeable } from
+    "@openzeppelin/contracts-upgradeable/utils/PausableUpgradeable.sol";
+import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+import { IERC20Metadata } from
+    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
+import { IPoolAddressesProvider } from
+    "@aave/contracts/interfaces/IPoolAddressesProvider.sol";
+import { IPool } from "@aave/contracts/interfaces/IPool.sol";
+import { ILoopStrategy, IERC4626 } from "./interfaces/ILoopStrategy.sol";
+import { LoanLogic } from "./libraries/LoanLogic.sol";
+import { RebalanceLogic } from "./libraries/RebalanceLogic.sol";
+import { LoopStrategyStorage as Storage } from
+    "./storage/LoopStrategyStorage.sol";
+import {
+    CollateralRatio,
+    LoanState,
+    LendingPool,
+    StrategyAssets
+} from "./types/DataTypes.sol";
+import { ConversionMath } from "./libraries/math/ConversionMath.sol";
+import { RebalanceMath } from "./libraries/math/RebalanceMath.sol";
+import { USDWadRayMath } from "./libraries/math/USDWadRayMath.sol";
+import { SafeERC20 } from
+    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+import { ISwapper } from "./interfaces/ISwapper.sol";
+import { IWrappedERC20PermissionedDeposit } from
+    "./interfaces/IWrappedERC20PermissionedDeposit.sol";
+import { AccessControlUpgradeable } from
+    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
+import { UUPSUpgradeable } from
+    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
+
+/// @title LoopStrategy
+/// @notice Integrated Liquidity Market strategy for amplifying the cbETH staking rewards
+contract LoopStrategy is
+    ILoopStrategy,
+    ERC4626Upgradeable,
+    AccessControlUpgradeable,
+    PausableUpgradeable,
+    UUPSUpgradeable
+{
+    using USDWadRayMath for uint256;
+
+    /// @dev role which can pause and unpause deposits and withdrawals
+    bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");
+    /// @dev role which can change strategy parameters
+    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
+    /// @dev role which can upgrade the contract
+    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
+
+    constructor() {
+        _disableInitializers();
+    }
+
+    function LoopStrategy_init(
+        string memory _erc20name,
+        string memory _erc20symbol,
+        address _initialAdmin,
+        StrategyAssets memory _strategyAssets,
+        CollateralRatio memory _collateralRatioTargets,
+        IPoolAddressesProvider _poolAddressProvider,
+        IPriceOracleGetter _oracle,
+        ISwapper _swapper,
+        uint256 _ratioMargin,
+        uint16 _maxIterations
+    ) external initializer {
+        __ERC4626_init(_strategyAssets.underlying);
+        __Pausable_init();
+        __AccessControl_init();
+        __UUPSUpgradeable_init();
+        __ERC20_init(_erc20name, _erc20symbol);
+
+        _grantRole(DEFAULT_ADMIN_ROLE, _initialAdmin);
+
+        Storage.Layout storage $ = Storage.layout();
+        $.assets = _strategyAssets;
+        $.collateralRatioTargets = _collateralRatioTargets;
+        $.poolAddressProvider = _poolAddressProvider;
+        $.oracle = _oracle;
+        $.swapper = _swapper;
+        $.ratioMargin = _ratioMargin;
+        $.maxIterations = _maxIterations;
+
+        $.lendingPool = LendingPool({
+            pool: IPool(_poolAddressProvider.getPool()),
+            // 2 is the variable interest rate mode
+            interestRateMode: 2
+        });
+
+        // there is no assets cap until it's otherwise set by the setter function
+        $.assetsCap = type(uint256).max;
+
+        // approving to lending pool collateral and debt assets in advance
+        $.assets.collateral.approve(
+            address($.lendingPool.pool), type(uint256).max
+        );
+        $.assets.debt.approve(address($.lendingPool.pool), type(uint256).max);
+    }
+
+    /// @inheritdoc UUPSUpgradeable
+    function _authorizeUpgrade(address)
+        internal
+        override
+        onlyRole(UPGRADER_ROLE)
+    { }
+
+    /// @inheritdoc ILoopStrategy
+    function pause() external override onlyRole(PAUSER_ROLE) {
+        _pause();
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function unpause() external override onlyRole(PAUSER_ROLE) {
+        _unpause();
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function setInterestRateMode(uint256 _interestRateMode)
+        external
+        override
+        onlyRole(MANAGER_ROLE)
+    {
+        Storage.layout().lendingPool.interestRateMode = _interestRateMode;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function setCollateralRatioTargets(CollateralRatio memory targets)
+        external
+        override
+        onlyRole(MANAGER_ROLE)
+    {
+        if (
+            targets.minForRebalance > targets.target
+                || targets.maxForRebalance < targets.target
+                || targets.minForRebalance > targets.minForWithdrawRebalance
+                || targets.maxForRebalance < targets.maxForDepositRebalance
+        ) {
+            revert InvalidCollateralRatioTargets();
+        }
+
+        Storage.layout().collateralRatioTargets = targets;
+
+        emit CollateralRatioTargetsSet(targets);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getCollateralRatioTargets()
+        external
+        view
+        override
+        returns (CollateralRatio memory ratio)
+    {
+        return Storage.layout().collateralRatioTargets;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function equityUSD() public view override returns (uint256 amount) {
+        LoanState memory state =
+            LoanLogic.getLoanState(Storage.layout().lendingPool);
+        return state.collateralUSD - state.debtUSD;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function equity() public view override returns (uint256 amount) {
+        return _convertUSDValueToUnderlyingAsset(equityUSD());
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function debt() external view override returns (uint256 amount) {
+        return LoanLogic.getLoanState(Storage.layout().lendingPool).debtUSD;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function collateral() external view override returns (uint256 amount) {
+        return
+            LoanLogic.getLoanState(Storage.layout().lendingPool).collateralUSD;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function currentCollateralRatio()
+        external
+        view
+        override
+        returns (uint256 ratio)
+    {
+        LoanState memory state =
+            LoanLogic.getLoanState(Storage.layout().lendingPool);
+        return
+            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function rebalance()
+        external
+        override
+        whenNotPaused
+        returns (uint256 ratio)
+    {
+        if (!rebalanceNeeded()) {
+            revert RebalanceNotNeeded();
+        }
+        Storage.Layout storage $ = Storage.layout();
+        return RebalanceLogic.rebalanceTo(
+            $,
+            LoanLogic.getLoanState($.lendingPool),
+            $.collateralRatioTargets.target
+        );
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function rebalanceNeeded()
+        public
+        view
+        override
+        returns (bool shouldRebalance)
+    {
+        Storage.Layout storage $ = Storage.layout();
+        LoanState memory state = LoanLogic.getLoanState($.lendingPool);
+        return RebalanceLogic.rebalanceNeeded(
+            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD),
+            $.collateralRatioTargets
+        );
+    }
+
+    /// @inheritdoc IERC4626
+    function totalAssets()
+        public
+        view
+        override(ERC4626Upgradeable, IERC4626)
+        returns (uint256)
+    {
+        return equity();
+    }
+
+    /// @inheritdoc IERC4626
+    function maxDeposit(address)
+        public
+        view
+        override(ERC4626Upgradeable, IERC4626)
+        returns (uint256)
+    {
+        return Storage.layout().assetsCap - totalAssets();
+    }
+
+    /// @inheritdoc IERC4626
+    function deposit(uint256 assets, address receiver)
+        public
+        override(ERC4626Upgradeable, IERC4626)
+        whenNotPaused
+        returns (uint256 shares)
+    {
+        shares = _deposit(assets, receiver, 0);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function deposit(
+        uint256 assets,
+        address receiver,
+        uint256 minSharesReceived
+    ) external override whenNotPaused returns (uint256 shares) {
+        shares = _deposit(assets, receiver, minSharesReceived);
+    }
+
+    /// @inheritdoc IERC4626
+    function previewDeposit(uint256 assets)
+        public
+        view
+        override(ERC4626Upgradeable, IERC4626)
+        returns (uint256)
+    {
+        return _convertToShares(
+            RebalanceLogic.estimateSupply(Storage.layout(), assets),
+            totalAssets()
+        );
+    }
+
+    /// @notice mint function is disabled because we can't get exact amount of input assets for given amount of resulting shares
+    function maxMint(address)
+        public
+        pure
+        override(ERC4626Upgradeable, IERC4626)
+        returns (uint256)
+    {
+        return 0;
+    }
+
+    /// @notice mint function is disabled because we can't get exact amount of input assets for given amount of resulting shares
+    function mint(uint256, address)
+        public
+        view
+        override(ERC4626Upgradeable, IERC4626)
+        whenNotPaused
+        returns (uint256)
+    {
+        revert MintDisabled();
+    }
+
+    /// @notice mint function is disabled because we can't get exact amount of input assets for given amount of resulting shares
+    function previewMint(uint256)
+        public
+        view
+        override(ERC4626Upgradeable, IERC4626)
+        whenNotPaused
+        returns (uint256)
+    {
+        revert MintDisabled();
+    }
+
+    /// @notice withdraw function is disabled because the exact amount of shares for a number of
+    /// tokens cannot be calculated accurately
+    function maxWithdraw(address)
+        public
+        pure
+        override(ERC4626Upgradeable, IERC4626)
+        returns (uint256)
+    {
+        return 0;
+    }
+
+    /// @notice withdraw function is disabled because the exact amount of shares for a number of
+    /// tokens cannot be calculated accurately
+    function withdraw(uint256, address, address)
+        public
+        view
+        override(ERC4626Upgradeable, IERC4626)
+        whenNotPaused
+        returns (uint256)
+    {
+        revert WithdrawDisabled();
+    }
+
+    /// @notice withdraw function is disabled because the exact amount of shares for a number of
+    /// tokens cannot be calculated accurately
+    function previewWithdraw(uint256)
+        public
+        view
+        override(ERC4626Upgradeable, IERC4626)
+        whenNotPaused
+        returns (uint256)
+    {
+        revert WithdrawDisabled();
+    }
+
+    /// @inheritdoc IERC4626
+    function redeem(uint256 shares, address receiver, address owner)
+        public
+        override(ERC4626Upgradeable, IERC4626)
+        whenNotPaused
+        returns (uint256)
+    {
+        return _redeem(shares, receiver, owner, 0);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function redeem(
+        uint256 shares,
+        address receiver,
+        address owner,
+        uint256 minUnderlyingAsset
+    ) external whenNotPaused returns (uint256 assets) {
+        return _redeem(shares, receiver, owner, minUnderlyingAsset);
+    }
+
+    /// @inheritdoc IERC4626
+    function previewRedeem(uint256 shares)
+        public
+        view
+        override(ERC4626Upgradeable, IERC4626)
+        returns (uint256)
+    {
+        return RebalanceLogic.estimateWithdraw(
+            Storage.layout(), shares, totalSupply()
+        );
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function setAssetsCap(uint256 assetsCap) external onlyRole(MANAGER_ROLE) {
+        Storage.layout().assetsCap = assetsCap;
+
+        emit AssetsCapSet(assetsCap);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function setUSDMargin(uint256 marginUSD) external onlyRole(MANAGER_ROLE) {
+        if (marginUSD > USDWadRayMath.USD) {
+            revert MarginOutsideRange();
+        }
+
+        Storage.layout().usdMargin = marginUSD;
+
+        emit USDMarginSet(marginUSD);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function setRatioMargin(uint256 marginUSD)
+        external
+        onlyRole(MANAGER_ROLE)
+    {
+        if (marginUSD > USDWadRayMath.USD) {
+            revert MarginOutsideRange();
+        }
+
+        Storage.layout().ratioMargin = marginUSD;
+
+        emit RatioMarginSet(marginUSD);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function setMaxIterations(uint16 iterations)
+        external
+        onlyRole(MANAGER_ROLE)
+    {
+        Storage.layout().maxIterations = iterations;
+
+        emit MaxIterationsSet(iterations);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function setSwapper(address swapper) external onlyRole(MANAGER_ROLE) {
+        Storage.layout().swapper = ISwapper(swapper);
+
+        emit SwapperSet(swapper);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getAssets() external view returns (StrategyAssets memory assets) {
+        return Storage.layout().assets;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getPoolAddressProvider()
+        external
+        view
+        returns (address poolAddressProvider)
+    {
+        return address(Storage.layout().poolAddressProvider);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getLendingPool() external view returns (LendingPool memory pool) {
+        return Storage.layout().lendingPool;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getOracle() external view returns (address oracle) {
+        return address(Storage.layout().oracle);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getSwapper() external view returns (address swapper) {
+        return address(Storage.layout().swapper);
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getUSDMargin() external view returns (uint256 marginUSD) {
+        return Storage.layout().usdMargin;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getRatioMagin() external view returns (uint256 marginUSD) {
+        return Storage.layout().ratioMargin;
+    }
+
+    /// @inheritdoc ILoopStrategy
+    function getMaxIterations() external view returns (uint256 iterations) {
+        return Storage.layout().maxIterations;
+    }
+
+    /// @notice deposit assets to the strategy with the requirement of equity received after rebalance
+    /// @param assets amount of assets to deposit
+    /// @param receiver address of the receiver of share tokens
+    /// @param minSharesReceived required minimum of equity received
+    /// @return shares number of received shares
+    function _deposit(
+        uint256 assets,
+        address receiver,
+        uint256 minSharesReceived
+    ) internal returns (uint256 shares) {
+        Storage.Layout storage $ = Storage.layout();
+
+        uint256 maxAssets = maxDeposit(receiver);
+        if (assets > maxAssets) {
+            revert ERC4626ExceededMaxDeposit(receiver, assets, maxAssets);
+        }
+
+        SafeERC20.safeTransferFrom(
+            $.assets.underlying, msg.sender, address(this), assets
+        );
+
+        assets = _convertUnderlyingToCollateralAsset($.assets, assets);
+
+        LoanState memory state = RebalanceLogic.updateState($);
+
+        uint256 prevTotalAssets = totalAssets();
+
+        RebalanceLogic.rebalanceAfterSupply($, state, assets);
+
+        uint256 equityReceived = totalAssets() - prevTotalAssets;
+        shares = _convertToShares(equityReceived, prevTotalAssets);
+
+        if (shares < minSharesReceived) {
+            revert SharesReceivedBelowMinimum(shares, minSharesReceived);
+        }
+
+        _mint(receiver, shares);
+
+        emit Deposit(msg.sender, receiver, assets, shares);
+        return shares;
+    }
+
+    /// @notice redeems an amount of shares by burning shares from the owner, and rewarding the receiver with
+    /// the share value
+    /// @param shares amount of shares to burn
+    /// @param receiver address to receive share value
+    /// @param owner address of share owner
+    /// @param minUnderlyingAsset minimum amount of underlying asset to receive
+    /// @return assets amount of underlying asset received
+    function _redeem(
+        uint256 shares,
+        address receiver,
+        address owner,
+        uint256 minUnderlyingAsset
+    ) internal returns (uint256 assets) {
+        Storage.Layout storage $ = Storage.layout();
+
+        uint256 shareUnderlyingAsset = _convertCollateralToUnderlyingAsset(
+            $.assets,
+            RebalanceLogic.rebalanceBeforeWithdraw($, shares, totalSupply())
+        );
+
+        // ensure equity in asset terms to be received is larger than
+        // minimum acceptable amount
+        if (shareUnderlyingAsset < minUnderlyingAsset) {
+            revert UnderlyingReceivedBelowMinimum(
+                shareUnderlyingAsset, minUnderlyingAsset
+            );
+        }
+
+        // burn shares from owner and send corresponding underlying asset ammount to receiver
+        _withdraw(_msgSender(), receiver, owner, shareUnderlyingAsset, shares);
+
+        return shareUnderlyingAsset;
+    }
+
+    /// @notice function is the same formula as in ERC4626 implementation, but totalAssets is passed as a parameter of the function
+    /// @notice we are using this function because totalAssets may change before we are able to calculate asset(equity) amount;
+    /// @notice that is because we are calculating assets based on change in totalAssets
+    /// @param _assets amount of assets provided
+    /// @param _totalAssets amount of total assets which are used in calculation of shares
+    /// @return shares
+    function _convertToShares(uint256 _assets, uint256 _totalAssets)
+        internal
+        view
+        virtual
+        returns (uint256 shares)
+    {
+        shares = Math.mulDiv(
+            _assets,
+            totalSupply() + 10 ** _decimalsOffset(),
+            _totalAssets + 1,
+            Math.Rounding.Floor
+        );
+    }
+
+    /// @notice converts underlying asset to the collateral asset if those are different
+    /// @param assets struct which contain underlying asset address and collateral asset address
+    /// @param collateralAmountAsset amount of collateral to convert
+    /// @return receivedAssets amount of received collateral assets
+    function _convertUnderlyingToCollateralAsset(
+        StrategyAssets storage assets,
+        uint256 collateralAmountAsset
+    ) internal virtual returns (uint256 receivedAssets) {
+        if (assets.underlying != assets.collateral) {
+            assets.underlying.approve(
+                address(assets.collateral), collateralAmountAsset
+            );
+            IWrappedERC20PermissionedDeposit(address(assets.collateral)).deposit(
+                collateralAmountAsset
+            );
+        }
+        receivedAssets = collateralAmountAsset;
+    }
+
+    /// @notice unwrap collateral asset to the underlying asset, if those are different
+    /// @param assets struct which contain underlying asset address and collateral asset address
+    /// @param collateralAmountAsset amount of collateral asset to unwrap
+    /// @return underlyingAmountAsset amount of received underlying assets
+    function _convertCollateralToUnderlyingAsset(
+        StrategyAssets storage assets,
+        uint256 collateralAmountAsset
+    ) internal virtual returns (uint256 underlyingAmountAsset) {
+        if (assets.underlying != assets.collateral) {
+            IWrappedERC20PermissionedDeposit(address(assets.collateral))
+                .withdraw(collateralAmountAsset);
+        }
+        underlyingAmountAsset = collateralAmountAsset;
+    }
+
+    /// @notice converts the USD value to the amount of underlying token assets
+    /// @param usdValue amount of USD to convert
+    function _convertUSDValueToUnderlyingAsset(uint256 usdValue)
+        internal
+        view
+        returns (uint256)
+    {
+        Storage.Layout storage $ = Storage.layout();
+
+        // get underlying price and decimals
+        uint256 underlyingPriceUSD =
+            $.oracle.getAssetPrice(address($.assets.underlying));
+        uint256 underlyingDecimals =
+            IERC20Metadata(address($.assets.underlying)).decimals();
+
+        return ConversionMath.convertUSDToAsset(
+            usdValue, underlyingPriceUSD, underlyingDecimals
+        );
+    }
+}
diff -ruN ../src/src/interfaces/IAerodromeAdapter.sol src/interfaces/IAerodromeAdapter.sol
--- ../src/src/interfaces/IAerodromeAdapter.sol	1970-01-01 02:00:00
+++ src/interfaces/IAerodromeAdapter.sol	2024-02-13 01:00:56
@@ -0,0 +1,99 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+import { IRouter } from "../vendor/aerodrome/IRouter.sol";
+
+/// @title IAerodromeAdapter
+/// @notice interface for AerodromeAdapter functionality
+interface IAerodromeAdapter {
+    /// @notice emitted when a value whether a pool is stable or not is set
+    /// @param from first token of the pool
+    /// @param to second token of the pool
+    /// @param status boolean value indicating pool stability
+    event IsPoolStableSet(IERC20 from, IERC20 to, bool status);
+
+    /// @notice emitted when the poolFactory address is set
+    /// @param factory address of poolFactory
+    event PoolFactorySet(address factory);
+
+    /// @notice emitted when the router address is set
+    /// @param router address of router
+    event RouterSet(address router);
+
+    /// @notice emitted when set routes for a given swap are removed
+    /// @param from address to swap from
+    /// @param to addrses to swap to
+    event RoutesRemoved(IERC20 from, IERC20 to);
+
+    /// @notice emitted when the swap routes for a token pair are set
+    /// @param from first token of the pool
+    /// @param to second token of the pool
+    /// @param routes array of routes for swap
+    event RoutesSet(IERC20 from, IERC20 to, IRouter.Route[] routes);
+
+    /// @notice initializing function of adapter
+    /// @param owner address of adapter owner
+    /// @param router address of Aerodrome router
+    /// @param factory address of Aerodrome pair factory
+    /// @param swapper address of swapper
+    function AerodromeAdapter__Init(
+        address owner,
+        address router,
+        address factory,
+        address swapper
+    ) external;
+
+    /// @notice sets the `isPoolStable` boolean for a given pair
+    /// @param from address of first token
+    /// @param to address of second token
+    /// @param status value to set `isPoolStable` to
+    function setIsPoolStable(IERC20 from, IERC20 to, bool status) external;
+
+    /// @notice sets the poolFactory address
+    /// @param factory poolFactory address
+    function setPoolFactory(address factory) external;
+
+    /// @notice sets the router address
+    /// @param router router address
+    function setRouter(address router) external;
+
+    /// @notice sets routes for a given swap
+    /// @param from address of token to swap from
+    /// @param to address of tokent to swap to
+    /// @param routes routes for the swap
+    function setRoutes(IERC20 from, IERC20 to, IRouter.Route[] memory routes)
+        external;
+
+    /// @notice deletes existing routes for a given swap
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    function removeRoutes(IERC20 from, IERC20 to) external;
+
+    /// @notice fetches the 'stable' status of a pool
+    /// @param from address of `from` token
+    /// @param to address of `to` token
+    /// @return status 'stable' status of pool
+    function getIsPoolStable(IERC20 from, IERC20 to)
+        external
+        view
+        returns (bool status);
+
+    /// @notice fetches the Aerodrome PoolFactory address
+    /// @return factory address of Aerodrome PoolFactory contract
+    function getPoolFactory() external view returns (address factory);
+
+    /// @notice fetches the Aerodrome Router address
+    /// @return router address of Aerodrome Router contract
+    function getRouter() external view returns (address router);
+
+    /// @notice fetches the swap routes for a given token swap
+    /// @param from address of `from` token
+    /// @param to address of `to` token
+    /// @return routes IRouter.Route struct array corresponding to the token swap
+    function getSwapRoutes(IERC20 from, IERC20 to)
+        external
+        view
+        returns (IRouter.Route[] memory routes);
+}
diff -ruN ../src/src/interfaces/ILoopStrategy.sol src/interfaces/ILoopStrategy.sol
--- ../src/src/interfaces/ILoopStrategy.sol	1970-01-01 02:00:00
+++ src/interfaces/ILoopStrategy.sol	2024-02-13 01:00:56
@@ -0,0 +1,213 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC4626 } from "@openzeppelin/contracts/interfaces/IERC4626.sol";
+import {
+    CollateralRatio,
+    LendingPool,
+    StrategyAssets
+} from "../types/DataTypes.sol";
+
+/// @title IStrategy
+/// @notice interface for Integration Liquiity Market strategies
+/// @dev interface similar to IERC4626, with some additional functions for health management
+interface ILoopStrategy is IERC4626 {
+    /// @notice mint function from IERC4626 is disabled
+    error MintDisabled();
+
+    /// @notice withdraw function from IERC4626 is disabled
+    error WithdrawDisabled();
+
+    /// @notice reverts when rebalance function is called but collateral ratio is in the target range
+    error RebalanceNotNeeded();
+
+    /// @notice reverts when attempting to set collateral ratio targets which are not logically consistent
+    /// in terms of their values
+    error InvalidCollateralRatioTargets();
+
+    /// @notice reverts when shares received by user on deposit is lower than given minimum
+    /// @param sharesReceived amount of shares received
+    /// @param minSharesReceived minimum defined by caller
+    error SharesReceivedBelowMinimum(
+        uint256 sharesReceived, uint256 minSharesReceived
+    );
+
+    /// @notice thrown when underlying received upon share redemption or asset withdrawing is
+    /// less than given minimum limit
+    /// @param underlyingReceived amount of underlying received
+    /// @param minUnderlyingReceived minimum amount of underlying to receive
+    error UnderlyingReceivedBelowMinimum(
+        uint256 underlyingReceived, uint256 minUnderlyingReceived
+    );
+
+    /// @notice thrown when attempting to set a margin value which is meant to lie between
+    /// 0 < margin < 1e8 (1 USD)
+    error MarginOutsideRange();
+
+    /// @notice thrown when the caller of the redeem function is not the owner of the
+    /// shares to be redeemed
+    error RedeemerNotOwner();
+
+    /// @notice emitted when a new value for the collateralRatioTargets is set
+    /// @param targets new value of collateralRatioTargest struct
+    event CollateralRatioTargetsSet(CollateralRatio targets);
+
+    /// @notice emitted when a new value for maxIterations is set
+    /// @param iterations new value for maxIterations
+    event MaxIterationsSet(uint16 iterations);
+
+    /// @notice emitted when a new value for ratioMargin is set
+    /// @param margin new value for ratioMargin
+    event RatioMarginSet(uint256 margin);
+
+    /// @notice emitted when a new value for usdMargin is set
+    /// @param margin new value for usdMargin
+    event USDMarginSet(uint256 margin);
+
+    /// @notice emitted when a new value for assets cap is set
+    /// @param assetsCap new value for assets cap
+    event AssetsCapSet(uint256 assetsCap);
+
+    /// @notice emitted when a new value for the swapper address is set
+    /// @param swapper new address of swapper contract
+    event SwapperSet(address swapper);
+
+    /// @notice returns the amount of equity belonging to the strategy
+    /// in underlying token value
+    /// @return amount equity amount
+    function equity() external view returns (uint256 amount);
+
+    /// @notice returns the amount of equity belonging to the strategy
+    /// in USD value
+    /// @return amount equity amount
+    function equityUSD() external view returns (uint256 amount);
+
+    /// @notice returns the amount of debt belonging to the strategy
+    /// in underlying value (USD)
+    /// @return amount debt amount
+    function debt() external view returns (uint256 amount);
+
+    /// @notice returns the amount of collateral belonging to the strategy
+    /// in underlying value (USD)
+    /// @return amount collateral amount
+    function collateral() external view returns (uint256 amount);
+
+    /// @notice pauses deposits and withdrawals from the contract
+    function pause() external;
+
+    /// @notice unpauses deposits and withdrawals from the contract
+    function unpause() external;
+
+    /// @notice sets the collateral ratio targets (target ratio, min and max for rebalance,
+    /// @notice max for deposit rebalance and min for collateral rebalance)
+    /// @param collateralRatioTargets collateral ratio targets struct
+    function setCollateralRatioTargets(
+        CollateralRatio memory collateralRatioTargets
+    ) external;
+
+    /// @notice returns min, max and target collateral ratio values
+    /// @return ratio struct containing min, max and target collateral ratio values
+    function getCollateralRatioTargets()
+        external
+        view
+        returns (CollateralRatio memory ratio);
+
+    /// @notice sets the interest rate mode for the loan
+    /// @param interestRateMode interest rate mode per aave enum InterestRateMode {NONE, STABLE, VARIABLE}
+    function setInterestRateMode(uint256 interestRateMode) external;
+
+    /// @notice returns the current collateral ratio value of the strategy
+    /// @return ratio current collateral ratio value
+    function currentCollateralRatio() external view returns (uint256 ratio);
+
+    /// @notice rebalances the strategy
+    /// @dev perofrms a downwards/upwards leverage depending on the current strategy state in order to be
+    /// within collateral ratio range
+    /// @return ratio value of collateral ratio after strategy rebalances
+    function rebalance() external returns (uint256 ratio);
+
+    /// @notice retruns true if collateral ratio is out of the target range, and we need to rebalance pool
+    /// @return shouldRebalance true if rebalance is needed
+    function rebalanceNeeded() external view returns (bool shouldRebalance);
+
+    /// @notice deposit assets to the strategy with the requirement of shares received
+    /// @param assets amount of assets to deposit
+    /// @param receiver address of the receiver of share tokens
+    /// @param minSharesReceived required minimum of shares received
+    /// @return shares number of received shares
+    function deposit(
+        uint256 assets,
+        address receiver,
+        uint256 minSharesReceived
+    ) external returns (uint256 shares);
+
+    /// @notice redeems an amount of shares by burning shares from the owner, and rewarding the receiver with
+    /// the share value
+    /// @param shares amount of shares to burn
+    /// @param receiver address to receive share value
+    /// @param owner address of share owner
+    /// @param minUnderlyingAsset minimum amount of underlying asset to receive
+    /// @return assets amount of underlying asset received
+    function redeem(
+        uint256 shares,
+        address receiver,
+        address owner,
+        uint256 minUnderlyingAsset
+    ) external returns (uint256 assets);
+
+    /// @notice sets the assets cap value
+    /// @param assetsCap new value of assets cap
+    function setAssetsCap(uint256 assetsCap) external;
+
+    /// @notice sets the usdMarginUSD value
+    /// @param marginUSD new value of usdMarginUSD
+    function setUSDMargin(uint256 marginUSD) external;
+
+    /// @notice sets the ratioMarginUSD value
+    /// @param marginUSD new value of ratioMarginUSD
+    function setRatioMargin(uint256 marginUSD) external;
+
+    /// @notice sets the maxIterations value
+    /// @param iterations new value of maxIterations
+    function setMaxIterations(uint16 iterations) external;
+
+    /// @notice sets the swapper contract address
+    /// @param swapper address of swapper contract
+    function setSwapper(address swapper) external;
+
+    /// @notice returns underlying StrategyAssets struct
+    /// @return assets underlying StrategyAssets struct
+    function getAssets() external view returns (StrategyAssets memory assets);
+
+    /// @notice returns poolAddressProvider contract address
+    /// @return poolAddressProvider poolAddressProvider contract address
+    function getPoolAddressProvider()
+        external
+        view
+        returns (address poolAddressProvider);
+
+    /// @notice returns LendingPool struct
+    /// @return pool LendingPool struct
+    function getLendingPool() external view returns (LendingPool memory pool);
+
+    /// @notice returns address of oracle contract
+    /// @return oracle address of oracle contract
+    function getOracle() external view returns (address oracle);
+
+    /// @notice returns address of swapper contract
+    /// @return swapper address of swapper contract
+    function getSwapper() external view returns (address swapper);
+
+    /// @notice returns value of usdMargin
+    /// @return marginUSD usdMargin value
+    function getUSDMargin() external view returns (uint256 marginUSD);
+
+    /// @notice returns value of ratioMargin
+    /// @return marginUSD ratioMargin value
+    function getRatioMagin() external view returns (uint256 marginUSD);
+
+    /// @notice returns value of maxIterations
+    /// @return iterations maxIterations value
+    function getMaxIterations() external view returns (uint256 iterations);
+}
diff -ruN ../src/src/interfaces/IPausable.sol src/interfaces/IPausable.sol
--- ../src/src/interfaces/IPausable.sol	1970-01-01 02:00:00
+++ src/interfaces/IPausable.sol	2024-02-13 01:00:56
@@ -0,0 +1,20 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+/// @title IPausable
+/// @notice interface for Pausable functionality
+interface IPausable {
+    /// @notice the operation failed because the contract is paused
+    error EnforcedPause();
+
+    /// @notice set paused state to true
+    function pause() external;
+
+    /// @notice set paused state to false
+    function unpause() external view;
+
+    /// @notice returns paused state
+    /// @param state true if paused, false if unpaused
+    function paused() external view returns (bool state);
+}
diff -ruN ../src/src/interfaces/IPriceOracleGetter.sol src/interfaces/IPriceOracleGetter.sol
--- ../src/src/interfaces/IPriceOracleGetter.sol	1970-01-01 02:00:00
+++ src/interfaces/IPriceOracleGetter.sol	2024-02-13 01:00:56
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: AGPL-3.0
+
+pragma solidity ^0.8.21;
+
+/**
+ * @title IPriceOracleGetter
+ * @author Aave
+ * @notice Interface for the Aave price oracle.
+ */
+
+interface IPriceOracleGetter {
+    /**
+     * @notice Returns the base currency address
+     * @dev Address 0x0 is reserved for USD as base currency.
+     * @return Returns the base currency address.
+     */
+    function BASE_CURRENCY() external view returns (address);
+
+    /**
+     * @notice Returns the base currency unit
+     * @dev 1 ether for ETH, 1e8 for USD.
+     * @return Returns the base currency unit.
+     */
+    function BASE_CURRENCY_UNIT() external view returns (uint256);
+
+    /**
+     * @notice Returns the asset price in the base currency
+     * @param asset The address of the asset
+     * @return The price of the asset
+     */
+    function getAssetPrice(address asset) external view returns (uint256);
+}
diff -ruN ../src/src/interfaces/ISwapAdapter.sol src/interfaces/ISwapAdapter.sol
--- ../src/src/interfaces/ISwapAdapter.sol	1970-01-01 02:00:00
+++ src/interfaces/ISwapAdapter.sol	2024-02-13 01:00:56
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+/// @title ISwapAdapter
+/// @notice interface for SwapAdapter contracts
+interface ISwapAdapter {
+    /// @notice thrown when attempting to call Swapper-gated functions
+    error NotSwapper();
+
+    /// @notice emitted when the Swapper contract is set for a given adapter
+    /// @param swapper address of Swapper contract
+    event SwapperSet(address swapper);
+
+    /// @notice swaps a given amount of a token to another token, sending the final amount to the beneficiary
+    /// @dev this is a function that _must_ be implemented by a swap adapter - all DEX-specific logic
+    /// is contained therein
+    /// @param from address of token to swap from
+    /// @param to address of token to swap to
+    /// @param fromAmount amount of from token to swap
+    /// @param beneficiary receiver of final to token amount
+    /// @return toAmount amount of to token returned from swapping
+    function executeSwap(
+        IERC20 from,
+        IERC20 to,
+        uint256 fromAmount,
+        address payable beneficiary
+    ) external returns (uint256 toAmount);
+
+    /// @notice sets the address of the Swapper contract
+    /// @dev this is a function that _must_ be implemented by a swap adapter
+    /// @param swapper address of Swapper contract
+    function setSwapper(address swapper) external;
+
+    /// @notice returns the address of Swapper contract
+    /// @dev this is a function that _must_ be implemented by a swap adapter - permissions
+    /// for calling swaps are granted to this address
+    /// @return swapper address of Swapper contract
+    function getSwapper() external view returns (address swapper);
+}
diff -ruN ../src/src/interfaces/ISwapper.sol src/interfaces/ISwapper.sol
--- ../src/src/interfaces/ISwapper.sol	1970-01-01 02:00:00
+++ src/interfaces/ISwapper.sol	2024-02-13 01:00:56
@@ -0,0 +1,135 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IPriceOracleGetter } from
+    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { Step } from "../types/DataTypes.sol";
+
+/// @title ISwapper
+/// @notice interface for Swapper contract
+/// @dev Swapper contract functions as registry and router for Swapper Adapters
+interface ISwapper {
+    /// @notice thrown when attempting to set a USD value which is outside the USD range
+    /// of ONE_USD (1e8)
+    error USDValueOutsideRange();
+
+    /// @notice thrown when attempting to set a maximum acceptable slippage for a given
+    /// token which exceeds ONE_WAD (1e18)
+    error SlippageOutsideRange();
+
+    /// @notice thrown when attempting to set a route which has the zero-address as
+    /// the address of the adapter
+    error InvalidAddress();
+
+    /// @notice thrown when msg.sender attempting to call executeSwap without being part of the
+    /// strategies enumerable set
+    error NotStrategy();
+
+    /// @notice thrown when less tokens than the minimum are returned after a swap
+    error MaxSlippageExceeded();
+
+    /// @notice emitted when a route is set for a given swap
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    /// @param steps array of Step structs needed to perform swap
+    event RouteSet(IERC20 indexed from, IERC20 indexed to, Step[] steps);
+
+    /// @notice emitted when the offsetFactor of a route is set for a given swap
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    /// @param offsetUSD offsetFactor from 0 - 1e8
+    event OffsetFactorSet(
+        IERC20 indexed from, IERC20 indexed to, uint256 offsetUSD
+    );
+
+    /// @notice emitted when the oracle for a given token is set
+    /// @param oracle address of PriceOracleGetter contract
+    event OracleSet(IPriceOracleGetter oracle);
+
+    /// @notice emitted when a new value for the allowed deviation from the offsetFactor
+    /// is set
+    event OffsetDeviationSet(uint256 offsetDeviationUSD);
+
+    /// @notice emitted when a route is removed
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    event RouteRemoved(IERC20 indexed from, IERC20 indexed to);
+
+    /// @notice emitted when a strategy is added to strategies enumerable set
+    /// @param strategy address of added strategy
+    event StrategyAdded(address strategy);
+
+    /// @notice emitted when a strategy is removed from strategies enumerable set
+    /// @param strategy address of added strategy
+    event StrategyRemoved(address strategy);
+
+    /// @notice returns the steps of a swap route
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    /// @return steps array of swap steps needed to end up with `to` token from `from` token
+    function getRoute(IERC20 from, IERC20 to)
+        external
+        returns (Step[] memory steps);
+
+    /// @notice sets the a steps of a swap route
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    /// @param steps  array of swap steps needed to end up with `to` token from `from` token
+    function setRoute(IERC20 from, IERC20 to, Step[] calldata steps) external;
+
+    /// @notice deletes an existing route
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    function removeRoute(IERC20 from, IERC20 to) external;
+
+    /// @notice swaps a given amount of a token to another token, sending the final amount to the beneficiary
+    /// @param from address of token to swap from
+    /// @param to address of token to swap to
+    /// @param fromAmount amount of from token to swap
+    /// @param beneficiary receiver of final to token amount
+    /// @return toAmount amount of to token returned from swapping
+    function swap(
+        IERC20 from,
+        IERC20 to,
+        uint256 fromAmount,
+        address payable beneficiary
+    ) external returns (uint256 toAmount);
+
+    /// @notice calculates the offset factor for the entire swap route from `from` token to `to` token
+    /// @param from address of `from` token
+    /// @param to address of `to` token
+    /// @return offsetUSD factor between 0 - 1e8 to represent offset (1e8 is 100% offset so 0 value returned)
+    function offsetFactor(IERC20 from, IERC20 to)
+        external
+        view
+        returns (uint256 offsetUSD);
+
+    /// @notice sets the offset factor for the entire swap route from `from` token to `to` token
+    /// @param from address of `from` token
+    /// @param to address of `to` token
+    /// @param offsetUSD factor between 0 - 1e8 to represent offset (1e8 is 100% offset so 0 value returned)
+    function setOffsetFactor(IERC20 from, IERC20 to, uint256 offsetUSD)
+        external;
+
+    /// @notice sets a new value for the offsetDeviationUSD from the offsetFactor
+    /// @param offsetDeviationUSD new value for the offsetDeviationUSD
+    function setOffsetDeviationUSD(uint256 offsetDeviationUSD) external;
+
+    /// @notice sets a new address for the oracle
+    /// @param oracle new IPriceOracleGetter contract address
+    function setOracle(IPriceOracleGetter oracle) external;
+
+    /// @notice returns address of oracle contract
+    /// @return oracle address of oracle contract
+    function getOracle() external view returns (IPriceOracleGetter oracle);
+
+    /// @notice returns offsetDeviationUSD value
+    /// @return offsetDeviationUSD offsetDeviationUSD value
+    function getOffsetDeviationUSD()
+        external
+        view
+        returns (uint256 offsetDeviationUSD);
+}
diff -ruN ../src/src/interfaces/IWrappedERC20PermissionedDeposit.sol src/interfaces/IWrappedERC20PermissionedDeposit.sol
--- ../src/src/interfaces/IWrappedERC20PermissionedDeposit.sol	1970-01-01 02:00:00
+++ src/interfaces/IWrappedERC20PermissionedDeposit.sol	2024-02-13 01:00:56
@@ -0,0 +1,56 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+/// @title IWrappedERC20PermissionedDeposit
+/// @notice interface for the Wrapper of ERC20 with permissioned deposit
+/// @dev Wraps the underlying ERC20 contract and mints the same amount of a wrapped token.
+/// @dev Deposits are permissioned but withdrawals are open to any address.
+interface IWrappedERC20PermissionedDeposit is IERC20 {
+    /// @notice Sender doesn't have a permission to deposit
+    /// @param sender sender address
+    error NotDepositor(address sender);
+
+    /// @notice Deposit/wrapping underlying token
+    /// @param account account doing the deposit
+    /// @param amount amount of tokens deposited
+    event Deposit(address account, uint256 amount);
+
+    /// @notice Withdraw/unwrapping underlying token
+    /// @param account account doing the withdraw
+    /// @param amount amount of withdrawn tokens
+    event Withdraw(address account, uint256 amount);
+
+    /// @notice Sets deposit permission
+    /// @param account account to set permission for
+    /// @param toSet flag to give/withdraw pemission
+    event SetDepositPermission(address account, bool toSet);
+
+    /// @notice Recovers surplus of underlying token
+    /// @param account account which is doing recovering action
+    /// @param amountSurplus surplus amount recovored
+    event RecoverUnderlyingSurplus(address account, uint256 amountSurplus);
+
+    /// @notice retruns the underlying token address
+    /// @return underlyingToken underlying token
+    function underlying() external view returns (IERC20 underlyingToken);
+
+    /// @notice deposits underlying tokens and mint the same amount of wrapped tokens
+    /// @param amount amount of the tokens to wrap, in wei
+    /// @dev only permissioned depositors are allowed to deposit
+    function deposit(uint256 amount) external;
+
+    /// @notice burns amount of wrapped tokens and recieves back the underlying token
+    /// @param amount amount of the tokens to withdraw, in wei
+    function withdraw(uint256 amount) external;
+
+    /// @notice function used to recover underlying tokens sent directly to this contract by mistake
+    function recover() external;
+
+    /// @notice gives or withdraws permission to deposit
+    /// @param account account address to give/withdraw permission
+    /// @param toSet flag set to true to give permission, or false to withdraw permission
+    function setDepositPermission(address account, bool toSet) external;
+}
diff -ruN ../src/src/interfaces/IWrappedTokenAdapter.sol src/interfaces/IWrappedTokenAdapter.sol
--- ../src/src/interfaces/IWrappedTokenAdapter.sol	1970-01-01 02:00:00
+++ src/interfaces/IWrappedTokenAdapter.sol	2024-02-13 01:00:56
@@ -0,0 +1,42 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { IWrappedERC20PermissionedDeposit } from
+    "../interfaces/IWrappedERC20PermissionedDeposit.sol";
+
+/// @title IWrappedTokenAdapter
+/// @notice interface for WrappedTokenAdapter functionality
+interface IWrappedTokenAdapter {
+    /// @notice initializing function of adapter
+    /// @param owner address of adapter owner
+    /// @param swapper address of swapper
+    function WrappedTokenAdapter__Init(address owner, address swapper)
+        external;
+
+    /// @notice sets the wrapper contract for a given token pair
+    /// @param from token to wrap/unwrap
+    /// @param to token received after wrapping/unwrapping
+    /// @param wrapper WrappedERC20PermissionedDeposit contract pertaining to from/to tokens
+    function setWrapper(
+        IERC20 from,
+        IERC20 to,
+        IWrappedERC20PermissionedDeposit wrapper
+    ) external;
+
+    /// @notice removes a previously set wrapper for a given from/to token pair
+    /// @param from token to wrap/unwrap
+    /// @param to token received after wrapping/unwrapping
+    function removeWrapper(IERC20 from, IERC20 to) external;
+
+    /// @notice returns wrapper contract for a given from/to token pair
+    /// @param from token to wrap/unwrap
+    /// @param to token received after wrapping/unwrapping
+    /// @return wrapper WrappedERC20PermissionedDeposit contract pertaining to from/to tokens
+    function getWrapper(IERC20 from, IERC20 to)
+        external
+        view
+        returns (IWrappedERC20PermissionedDeposit wrapper);
+}
diff -ruN ../src/src/libraries/LoanLogic.sol src/libraries/LoanLogic.sol
--- ../src/src/libraries/LoanLogic.sol	1970-01-01 02:00:00
+++ src/libraries/LoanLogic.sol	2024-02-13 11:39:07
@@ -0,0 +1,248 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+import { IERC20Metadata } from
+    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
+import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";
+import { IPoolAddressesProvider } from
+    "@aave/contracts/interfaces/IPoolAddressesProvider.sol";
+import { IPool } from "@aave/contracts/interfaces/IPool.sol";
+import { IVariableDebtToken } from
+    "@aave/contracts/interfaces/IVariableDebtToken.sol";
+import { ReserveConfiguration } from
+    "@aave/contracts/protocol/libraries/configuration/ReserveConfiguration.sol";
+import { DataTypes } from
+    "@aave/contracts/protocol/libraries/types/DataTypes.sol";
+import { PercentageMath } from
+    "@aave/contracts/protocol/libraries/math/PercentageMath.sol";
+import { USDWadRayMath } from "./math/USDWadRayMath.sol";
+import { LoanState, LendingPool } from "../types/DataTypes.sol";
+
+/// @title LoanLogic
+/// @notice Contains all logic required for managing the loan position on the Seamless protocol
+/// @dev when calling pool functions, `onBehalfOf` is set to `address(this)` which, in most cases,
+/// @dev represents the strategy vault contract.
+library LoanLogic {
+    using USDWadRayMath for uint256;
+    using ReserveConfiguration for DataTypes.ReserveConfigurationMap;
+
+    /// @dev used for availableBorrowsBase and maxWithdrawAmount to decrease them by 0.01%
+    /// @dev because precision issues on converting to asset amounts can revert borrow/withdraw on lending pool
+    uint256 public constant MAX_AMOUNT_PERCENT = 9999;
+
+    /// @notice collateralizes an amount of the given asset via depositing assets into Seamless lending pool
+    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
+    /// @param asset address of collateral asset
+    /// @param amount amount of asset to collateralize
+    /// @return state loan state after supply call
+    function supply(
+        LendingPool memory lendingPool,
+        IERC20 asset,
+        uint256 amount
+    ) external returns (LoanState memory state) {
+        lendingPool.pool.supply(address(asset), amount, address(this), 0);
+        return getLoanState(lendingPool);
+    }
+
+    /// @notice withdraws collateral from the lending pool
+    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
+    /// @param asset address of collateral asset
+    /// @param amount amount of asset to withdraw
+    /// @return state loan state after supply call
+    function withdraw(
+        LendingPool memory lendingPool,
+        IERC20 asset,
+        uint256 amount
+    ) external returns (LoanState memory state) {
+        lendingPool.pool.withdraw(address(asset), amount, address(this));
+        return getLoanState(lendingPool);
+    }
+
+    /// @notice borrows an amount of borrowed asset from the lending pool
+    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
+    /// @param asset address of borrowing asset
+    /// @param amount amount of asset to borrow
+    /// @return state loan state after supply call
+    function borrow(
+        LendingPool memory lendingPool,
+        IERC20 asset,
+        uint256 amount
+    ) external returns (LoanState memory state) {
+        lendingPool.pool.borrow(
+            address(asset),
+            amount,
+            lendingPool.interestRateMode,
+            0,
+            address(this)
+        );
+        return getLoanState(lendingPool);
+    }
+
+    /// @notice repays an amount of borrowed asset to the lending pool
+    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
+    /// @param asset address of borrowing asset
+    /// @param amount amount of borrowing asset to repay
+    /// @return state loan state after supply call
+    function repay(LendingPool memory lendingPool, IERC20 asset, uint256 amount)
+        external
+        returns (LoanState memory state)
+    {
+        lendingPool.pool.repay(
+            address(asset), amount, lendingPool.interestRateMode, address(this)
+        );
+        return getLoanState(lendingPool);
+    }
+
+    /// @notice calculates the debt, and equity corresponding to an amount of shares
+    /// @dev collateral corresponding to shares is just sum of debt and equity
+    /// @param state loan state of strategy
+    /// @param shares amount of shares
+    /// @param totalShares total supply of shares
+    /// @return shareDebtUSD amount of debt in USD corresponding to shares
+    /// @return shareEquityUSD amount of equity in USD corresponding to shares
+    function shareDebtAndEquity(
+        LoanState memory state,
+        uint256 shares,
+        uint256 totalShares
+    ) internal pure returns (uint256 shareDebtUSD, uint256 shareEquityUSD) {
+        // calculate amount of debt and equity corresponding to shares in USD value
+        shareDebtUSD = state.debtUSD.usdMul(
+            USDWadRayMath.wadToUSD(shares.wadDiv(totalShares))
+        );
+        // to calculate equity, first collateral is calculated, and debt is subtracted from it
+        shareEquityUSD = state.collateralUSD.usdMul(
+            USDWadRayMath.wadToUSD(shares.wadDiv(totalShares))
+        ) - shareDebtUSD;
+    }
+
+    /// @notice returns the current state of loan position on the Seamless Protocol lending pool for the caller's account
+    /// @notice all returned values are in USD value
+    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
+    /// @return state loan state after supply call
+    function getLoanState(LendingPool memory lendingPool)
+        internal
+        view
+        returns (LoanState memory state)
+    {
+        (
+            uint256 totalCollateralUSD,
+            uint256 totalDebtUSD,
+            /* availableBorrowsUSD8 */
+            ,
+            uint256 currentLiquidationThreshold,
+            /* ltv */
+            ,
+            /* healthFactor */
+        ) = lendingPool.pool.getUserAccountData(address(this));
+
+        if (totalCollateralUSD == 0) {
+            return LoanState({
+                collateralUSD: 0,
+                debtUSD: 0,
+                maxWithdrawAmount: 0
+            });
+        }
+
+        uint256 maxWithdrawAmount;
+        // This can happen when the debt is already above liquidation trashold
+        // (due to collateral asset price fall, borrow asset price raise, or interest increase)
+        if (
+            totalCollateralUSD
+                < PercentageMath.percentDiv(
+                    totalDebtUSD, currentLiquidationThreshold
+                )
+        ) {
+            maxWithdrawAmount = 0;
+        } else {
+            maxWithdrawAmount = totalCollateralUSD
+                - PercentageMath.percentDiv(
+                    totalDebtUSD, currentLiquidationThreshold
+                );
+        }
+
+        maxWithdrawAmount =
+            PercentageMath.percentMul(maxWithdrawAmount, MAX_AMOUNT_PERCENT);
+
+        return LoanState({
+            collateralUSD: totalCollateralUSD,
+            debtUSD: totalDebtUSD,
+            maxWithdrawAmount: maxWithdrawAmount
+        });
+    }
+
+    /// @notice returns the available supply for the asset, taking into account defined borrow cap
+    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
+    /// @param asset asset for which the available supply is returned
+    /// @return availableAssetSupply available supply
+    function getAvailableAssetSupply(
+        LendingPool memory lendingPool,
+        IERC20 asset
+    ) internal view returns (uint256 availableAssetSupply) {
+        DataTypes.ReserveData memory reserveData =
+            lendingPool.pool.getReserveData(address(asset));
+
+        uint256 totalBorrow = _getTotalBorrow(reserveData);
+        uint256 borrowCap = reserveData.configuration.getBorrowCap();
+        uint256 assetUnit = 10 ** reserveData.configuration.getDecimals();
+        uint256 avilableUntilBorrowCap = (mulDivDown(borrowCap, assetUnit, 1) > totalBorrow)
+            ? mulDivDown(borrowCap, assetUnit, 1) - totalBorrow
+            : 0;
+        // uint256 avilableUntilBorrowCap = (borrowCap * assetUnit > totalBorrow) // Munged by Certora
+        //     ? borrowCap * assetUnit - totalBorrow // Munged by Certora
+        //     : 0;
+
+        uint256 availableLiquidityBase =
+            asset.balanceOf(reserveData.aTokenAddress);
+
+        availableAssetSupply =
+            Math.min(avilableUntilBorrowCap, availableLiquidityBase);
+        return availableAssetSupply;
+    }
+
+    /// @notice returns the total amount of borrow for given asset reserve data
+    /// @param reserveData reserve data (external type) for the asset
+    /// @return totalBorrow total borrowed amount
+    function _getTotalBorrow(DataTypes.ReserveData memory reserveData)
+        internal
+        view
+        returns (uint256 totalBorrow)
+    {
+        uint256 currScaledVariableDebt = IVariableDebtToken(
+            reserveData.variableDebtTokenAddress
+        ).scaledTotalSupply();
+        totalBorrow =
+            currScaledVariableDebt.rayMul(reserveData.variableBorrowIndex);
+        return totalBorrow;
+    }
+
+    /// @notice returns the maximum borrow avialble for the asset in USD terms, taking into account borrow cap and asset supply
+    /// @param lendingPool struct which contains lending pool setup (pool address and interest rate mode)
+    /// @param debtAsset asset for wich max borrow is returned
+    /// @param debtAssetPrice price of the asset
+    /// @return maxBorrowUSD maximum available borrow
+    function getMaxBorrowUSD(
+        LendingPool memory lendingPool,
+        IERC20 debtAsset,
+        uint256 debtAssetPrice
+    ) internal view returns (uint256 maxBorrowUSD) {
+        uint256 availableAssetSupply =
+            getAvailableAssetSupply(lendingPool, debtAsset);
+        uint256 assetDecimals = IERC20Metadata(address(debtAsset)).decimals();
+        uint256 availableAssetSupplyUSD =
+            mulDivDown(availableAssetSupply, debtAssetPrice, (10 ** assetDecimals));
+            //availableAssetSupply * debtAssetPrice / (10 ** assetDecimals); // Munged by Certora
+
+        (,, uint256 availableBorrowsUSD,,,) =
+            lendingPool.pool.getUserAccountData(address(this));
+        maxBorrowUSD = Math.min(availableBorrowsUSD, availableAssetSupplyUSD);
+        maxBorrowUSD =
+            PercentageMath.percentMul(maxBorrowUSD, MAX_AMOUNT_PERCENT);
+        return maxBorrowUSD;
+    }
+
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res) {
+            res = a * b / c;
+    }
+}
diff -ruN ../src/src/libraries/RebalanceLogic.sol src/libraries/RebalanceLogic.sol
--- ../src/src/libraries/RebalanceLogic.sol	1970-01-01 02:00:00
+++ src/libraries/RebalanceLogic.sol	2024-02-13 01:01:49
@@ -0,0 +1,645 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IPriceOracleGetter } from
+    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
+import { IERC20Metadata } from
+    "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
+
+import { LoanLogic } from "./LoanLogic.sol";
+import { ConversionMath } from "./math/ConversionMath.sol";
+import { RebalanceMath } from "./math/RebalanceMath.sol";
+import { USDWadRayMath } from "./math/USDWadRayMath.sol";
+import { ISwapper } from "../interfaces/ISwapper.sol";
+import { LoopStrategyStorage as Storage } from
+    "../storage/LoopStrategyStorage.sol";
+import {
+    LendingPool,
+    LoanState,
+    StrategyAssets,
+    CollateralRatio
+} from "../types/DataTypes.sol";
+
+/// @title RebalanceLogic
+/// @notice Contains all logic required for rebalancing
+library RebalanceLogic {
+    using USDWadRayMath for uint256;
+
+    /// @notice thrown when the final ratio after a rebalanceUp operation is outside
+    /// the allowed range
+    error RatioOutsideRange();
+
+    /// @dev ONE in USD scale and in WAD scale
+    uint256 internal constant ONE_USD = 1e8;
+    uint256 internal constant ONE_WAD = USDWadRayMath.WAD;
+
+    /// @dev decimals of USD prices as per _oracle, and WAD decimals
+    uint8 internal constant USD_DECIMALS = 8;
+    uint8 internal constant WAD_DECIMALS = 18;
+
+    /// @notice performs a rebalance operation after supplying an asset amount to the lending pool
+    /// @param $ the storage state of LendingStrategyStorage
+    /// @param state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
+    /// @param assets amount of assets to supply in tokens
+    function rebalanceAfterSupply(
+        Storage.Layout storage $,
+        LoanState memory state,
+        uint256 assets
+    ) external {
+        uint256 prevCollateralRatio =
+            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
+
+        state = LoanLogic.supply($.lendingPool, $.assets.collateral, assets);
+
+        uint256 afterCollateralRatio =
+            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
+
+        if (prevCollateralRatio == type(uint256).max) {
+            rebalanceTo($, state, $.collateralRatioTargets.target);
+        } else if (
+            afterCollateralRatio
+                > $.collateralRatioTargets.maxForDepositRebalance
+        ) {
+            uint256 rebalanceToRatio = prevCollateralRatio;
+            if (
+                $.collateralRatioTargets.maxForDepositRebalance
+                    > rebalanceToRatio
+            ) {
+                rebalanceToRatio =
+                    $.collateralRatioTargets.maxForDepositRebalance;
+            }
+
+            rebalanceTo($, state, rebalanceToRatio);
+        }
+    }
+
+    /// @notice performs a rebalance operation before withdrawing an equity asset amount from the lending pool,
+    /// during a redemption of shares
+    /// @param $ the storage state of LendingStrategyStorage
+    /// @param shares amount of shares to redeem
+    /// @param totalShares total supply of shares
+    /// @return shareEquityAsset amount of equity in asset corresponding to shares
+    function rebalanceBeforeWithdraw(
+        Storage.Layout storage $,
+        uint256 shares,
+        uint256 totalShares
+    ) external returns (uint256 shareEquityAsset) {
+        // get updated loan state
+        LoanState memory state = updateState($);
+
+        // calculate amount of debt and equity corresponding to shares in USD value
+        (uint256 shareDebtUSD, uint256 shareEquityUSD) =
+            LoanLogic.shareDebtAndEquity(state, shares, totalShares);
+
+        // if all shares are being withdrawn, then their debt is the strategy debt
+        // so in that case the redeemer incurs the full cost of paying back the debt
+        // and is left with the remaining equity
+        if (state.debtUSD == shareDebtUSD) {
+            // pay back the debt corresponding to the shares
+            rebalanceDownToDebt($, state, state.debtUSD - shareDebtUSD);
+
+            state = LoanLogic.getLoanState($.lendingPool);
+            shareEquityUSD = state.collateralUSD - state.debtUSD;
+        }
+        //check if withdrawal would lead to a collateral below minimum acceptable level
+        // if yes, rebalance until share debt is repaid, and decrease remaining share equity
+        // by equity cost of rebalance
+        else if (
+            RebalanceMath.collateralRatioUSD(
+                state.collateralUSD - shareEquityUSD, state.debtUSD
+            ) < $.collateralRatioTargets.minForWithdrawRebalance
+        ) {
+            if (
+                state.collateralUSD
+                    > $.collateralRatioTargets.minForWithdrawRebalance.usdMul(
+                        state.debtUSD
+                    )
+            ) {
+                // amount of equity in USD value which may be withdrawn from
+                // strategy without driving the collateral ratio below
+                // the minForWithdrawRebalance limit, thereby not requiring
+                // a rebalance operation
+                uint256 freeEquityUSD = state.collateralUSD
+                    - $.collateralRatioTargets.minForWithdrawRebalance.usdMul(
+                        state.debtUSD
+                    );
+
+                // adjust share debt to account for the free equity - since
+                // some equity may be withdrawn freely, not all the debt has to be
+                // repaid
+                shareDebtUSD = shareDebtUSD
+                    - freeEquityUSD.usdMul(shareDebtUSD).usdDiv(
+                        shareEquityUSD + shareDebtUSD - freeEquityUSD
+                    );
+            }
+
+            uint256 initialEquityUSD = state.collateralUSD - state.debtUSD;
+
+            // pay back the adjusted debt corresponding to the shares
+            rebalanceDownToDebt($, state, state.debtUSD - shareDebtUSD);
+
+            state = LoanLogic.getLoanState($.lendingPool);
+
+            // shares lose equity equal to the amount of equity lost for
+            // the rebalance to pay the adjusted debt
+            if (initialEquityUSD > (state.collateralUSD - state.debtUSD)) {
+                shareEquityUSD -=
+                    initialEquityUSD - (state.collateralUSD - state.debtUSD);
+            }
+        }
+
+        // convert equity to collateral asset
+        shareEquityAsset = ConversionMath.convertUSDToAsset(
+            shareEquityUSD,
+            $.oracle.getAssetPrice(address($.assets.collateral)),
+            IERC20Metadata(address($.assets.collateral)).decimals()
+        );
+
+        // withdraw and transfer equity asset amount
+        LoanLogic.withdraw($.lendingPool, $.assets.collateral, shareEquityAsset);
+    }
+
+    /// @notice performs all operations necessary to rebalance the loan state of the strategy upwards
+    /// @dev note that the current collateral/debt values are expected to be given in underlying value (USD)
+    /// @param $ the storage state of LendingStrategyStorage
+    /// @param state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
+    /// @param targetCR target value of collateral ratio to reach
+    /// @return ratio value of collateral ratio after rebalance
+    function rebalanceTo(
+        Storage.Layout storage $,
+        LoanState memory state,
+        uint256 targetCR
+    ) public returns (uint256 ratio) {
+        // current collateral ratio
+        ratio =
+            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
+
+        if (ratio > targetCR) {
+            return rebalanceUp($, state, ratio, targetCR);
+        } else {
+            return rebalanceDown($, state, ratio, targetCR);
+        }
+    }
+
+    /// @notice performs a rebalance if necessary and returns the updated state after
+    /// the potential rebalance
+    /// @param $ Storage.Layout struct
+    /// @return state current LoanState of strategy
+    function updateState(Storage.Layout storage $)
+        public
+        returns (LoanState memory state)
+    {
+        // get current loan state and calculate initial collateral ratio
+        state = LoanLogic.getLoanState($.lendingPool);
+        uint256 collateralRatio =
+            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
+
+        // if collateralRatio is outside range, user should not incur rebalance costs
+        if (
+            collateralRatio != type(uint256).max
+                && rebalanceNeeded(collateralRatio, $.collateralRatioTargets)
+        ) {
+            rebalanceTo($, state, $.collateralRatioTargets.target);
+
+            state = LoanLogic.getLoanState($.lendingPool);
+        }
+    }
+
+    /// @notice mimics the operations required to supply an asset to the lending pool, estimating
+    /// the overall equity added to the strategy in terms of underlying asset (1e18)
+    /// @param $ Storage.Layout struct
+    /// @param assets amount of collateral asset to be supplied
+    /// @return suppliedEquityAsset esimated amount of equity supplied in asset terms (1e18)
+    function estimateSupply(Storage.Layout storage $, uint256 assets)
+        external
+        view
+        returns (uint256 suppliedEquityAsset)
+    {
+        LoanState memory state = LoanLogic.getLoanState($.lendingPool);
+
+        uint256 currentCR =
+            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
+        uint256 estimateTargetCR;
+
+        uint256 underlyingPriceUSD =
+            $.oracle.getAssetPrice(address($.assets.underlying));
+        uint256 underlyingDecimals =
+            IERC20Metadata(address($.assets.underlying)).decimals();
+
+        uint256 assetsUSD = ConversionMath.convertAssetToUSD(
+            assets,
+            underlyingPriceUSD,
+            IERC20Metadata(address($.assets.underlying)).decimals()
+        );
+
+        if (currentCR == type(uint256).max) {
+            estimateTargetCR = $.collateralRatioTargets.target;
+        } else {
+            if (rebalanceNeeded(currentCR, $.collateralRatioTargets)) {
+                currentCR = $.collateralRatioTargets.target;
+            }
+
+            uint256 afterCR = RebalanceMath.collateralRatioUSD(
+                state.collateralUSD + assetsUSD, state.debtUSD
+            );
+            if (afterCR > $.collateralRatioTargets.maxForDepositRebalance) {
+                estimateTargetCR = currentCR;
+                if (
+                    $.collateralRatioTargets.maxForDepositRebalance
+                        > estimateTargetCR
+                ) {
+                    estimateTargetCR =
+                        $.collateralRatioTargets.maxForDepositRebalance;
+                }
+            } else {
+                estimateTargetCR = afterCR;
+            }
+        }
+
+        uint256 offsetFactor =
+            $.swapper.offsetFactor($.assets.collateral, $.assets.debt);
+        uint256 borrowAmountUSD = RebalanceMath.requiredBorrowUSD(
+            estimateTargetCR, assetsUSD, 0, offsetFactor
+        );
+        uint256 collateralAfterUSD = borrowAmountUSD.usdMul(estimateTargetCR);
+        uint256 estimatedEquityUSD = collateralAfterUSD - borrowAmountUSD;
+
+        return ConversionMath.convertUSDToAsset(
+            estimatedEquityUSD, underlyingPriceUSD, underlyingDecimals
+        );
+    }
+
+    /// @notice mimics the operations required to withdraw an asset from the lending pool, estimating
+    /// the overall equity received from the strategy in terms of underlying asset (1e18)
+    /// @param $ Storage.Layout struct
+    /// @param shares amount of shares to burn to receive equity
+    /// @param totalShares total supply of shares
+    /// @return shareEquityAsset amount of equity assets received for the burnt shares
+    function estimateWithdraw(
+        Storage.Layout storage $,
+        uint256 shares,
+        uint256 totalShares
+    ) external view returns (uint256 shareEquityAsset) {
+        // get current loan state and calculate initial collateral ratio
+        LoanState memory state = LoanLogic.getLoanState($.lendingPool);
+
+        uint256 collateralRatio =
+            RebalanceMath.collateralRatioUSD(state.collateralUSD, state.debtUSD);
+
+        // if collateralRatio is outside range, user should not incur rebalance costs
+        if (
+            collateralRatio != type(uint256).max
+                && rebalanceNeeded(collateralRatio, $.collateralRatioTargets)
+        ) {
+            // calculate amount of collateral needed to bring the collateral ratio
+            // to target
+            uint256 neededCollateralUSD = RebalanceMath.requiredCollateralUSD(
+                $.collateralRatioTargets.target,
+                state.collateralUSD,
+                state.debtUSD,
+                $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
+            );
+
+            // calculate new debt and collateral values after collateral has been exchanged
+            // for rebalance
+            state.collateralUSD -= neededCollateralUSD;
+            state.debtUSD -= RebalanceMath.offsetUSDAmountDown(
+                neededCollateralUSD,
+                $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
+            );
+        }
+
+        // calculate amount of debt and equity corresponding to shares in USD value
+        (uint256 shareDebtUSD, uint256 shareEquityUSD) =
+            LoanLogic.shareDebtAndEquity(state, shares, totalShares);
+
+        // case when redeemer is redeeming all remaining shares
+        if (state.debtUSD == shareDebtUSD) {
+            uint256 collateralNeededUSD = shareDebtUSD.usdDiv(
+                USDWadRayMath.USD
+                    - $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
+            );
+
+            shareEquityUSD -= collateralNeededUSD.usdMul(
+                $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
+            );
+        } else if (
+            RebalanceMath.collateralRatioUSD(
+                state.collateralUSD - shareEquityUSD, state.debtUSD
+            ) < $.collateralRatioTargets.minForWithdrawRebalance
+        ) {
+            if (
+                state.collateralUSD
+                    > $.collateralRatioTargets.minForWithdrawRebalance.usdMul(
+                        state.debtUSD
+                    )
+            ) {
+                // amount of equity in USD value which may be withdrawn from
+                // strategy without driving the collateral ratio below
+                // the minForWithdrawRebalance limit, thereby not requiring
+                // a rebalance operation
+                uint256 freeEquityUSD = state.collateralUSD
+                    - $.collateralRatioTargets.minForWithdrawRebalance.usdMul(
+                        state.debtUSD
+                    );
+
+                // adjust share debt to account for the free equity - since
+                // some equity may be withdrawn freely, not all the debt has to be
+                // repaid
+                shareDebtUSD = shareDebtUSD
+                    - freeEquityUSD.usdMul(shareDebtUSD).usdDiv(
+                        shareEquityUSD + shareDebtUSD - freeEquityUSD
+                    );
+            }
+
+            // amount of collateral needed for repaying debt of shares after
+            // freeEquityUSD is accounted for
+            uint256 neededCollateralUSD = shareDebtUSD.usdDiv(
+                USDWadRayMath.USD
+                    - $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
+            );
+
+            shareEquityUSD -= neededCollateralUSD.usdMul(
+                $.swapper.offsetFactor($.assets.underlying, $.assets.debt)
+            );
+        }
+
+        shareEquityAsset = ConversionMath.convertUSDToAsset(
+            shareEquityUSD,
+            $.oracle.getAssetPrice(address($.assets.underlying)),
+            IERC20Metadata(address($.assets.underlying)).decimals()
+        );
+
+        return shareEquityAsset;
+    }
+
+    /// @notice performs all operations necessary to rebalance the loan state of the strategy upwards
+    /// @dev "upwards" in this context means reducing collateral ratio, thereby _increasing_ exposure
+    /// @dev note that the current collateral/debt values are expected to be given in underlying value (USD)
+    /// @param $ the storage state of LendingStrategyStorage
+    /// @param _state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
+    /// @param _currentCR current value of collateral ratio
+    /// @param _targetCR target value of collateral ratio to reach
+    /// @return ratio value of collateral ratio after rebalance
+    function rebalanceUp(
+        Storage.Layout storage $,
+        LoanState memory _state,
+        uint256 _currentCR,
+        uint256 _targetCR
+    ) internal returns (uint256 ratio) {
+        // current collateral ratio
+        ratio = _currentCR;
+
+        uint256 debtPriceUSD = $.oracle.getAssetPrice(address($.assets.debt));
+        uint8 debtDecimals = IERC20Metadata(address($.assets.debt)).decimals();
+
+        // get offset caused by DEX fees + slippage
+        uint256 offsetFactor =
+            $.swapper.offsetFactor($.assets.debt, $.assets.collateral);
+
+        uint256 margin = mulDivDown(_targetCR, $.ratioMargin, ONE_USD);
+        //uint256 margin = _targetCR * $.ratioMargin / ONE_USD; // Munged by Certora
+        uint256 count;
+
+        do {
+            // maximum borrowable amount in USD
+            uint256 borrowAmountUSD = LoanLogic.getMaxBorrowUSD(
+                $.lendingPool,
+                $.assets.debt,
+                $.oracle.getAssetPrice(address($.assets.debt))
+            );
+
+            {
+                // calculate how much borrow amount in USD is needed to reach
+                // targetCR
+                uint256 neededBorrowUSD = RebalanceMath.requiredBorrowUSD(
+                    _targetCR,
+                    _state.collateralUSD,
+                    _state.debtUSD,
+                    offsetFactor
+                );
+
+                // if less than the max borrow amount possible is needed,
+                // use the amount that is required to reach targetCR
+                borrowAmountUSD = borrowAmountUSD < neededBorrowUSD
+                    ? borrowAmountUSD
+                    : neededBorrowUSD;
+            }
+
+            // convert borrowAmount from USD to a borrowAsset amount
+            uint256 borrowAmountAsset = ConversionMath.convertUSDToAsset(
+                borrowAmountUSD, debtPriceUSD, debtDecimals
+            );
+
+            if (borrowAmountAsset == 0) {
+                break;
+            }
+
+            // borrow _assets from lending _pool
+            LoanLogic.borrow($.lendingPool, $.assets.debt, borrowAmountAsset);
+
+            // approve _swapper contract to swap asset
+            $.assets.debt.approve(address($.swapper), borrowAmountAsset);
+
+            // exchange debtAmountAsset of debt tokens for collateral tokens
+            uint256 collateralAmountAsset = $.swapper.swap(
+                $.assets.debt,
+                $.assets.collateral,
+                borrowAmountAsset,
+                payable(address(this))
+            );
+
+            if (collateralAmountAsset == 0) {
+                break;
+            }
+
+            // collateralize _assets in lending _pool
+            _state = LoanLogic.supply(
+                $.lendingPool, $.assets.collateral, collateralAmountAsset
+            );
+
+            // update collateral ratio value
+            ratio = RebalanceMath.collateralRatioUSD(
+                _state.collateralUSD, _state.debtUSD
+            );
+
+            if (++count > $.maxIterations) {
+                break;
+            }
+        } while (_targetCR + margin < ratio);
+
+        // prevent over exposure
+        if (ratio < $.collateralRatioTargets.minForRebalance) {
+            revert RatioOutsideRange();
+        }
+    }
+
+    /// @notice performs all operations necessary to rebalance the loan state of the strategy downwards
+    /// @dev "downards" in this context means increasing collateral ratio, thereby _decreasing_ exposure
+    /// @dev note that the current collateral/debt values are expected to be given in underlying value (USD)
+    /// @param $ the storage state of LendingStrategyStorage
+    /// @param state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
+    /// @param currentCR current value of collateral ratio
+    /// @param targetCR target value of collateral ratio to reach
+    /// @return ratio value of collateral ratio after rebalance
+    function rebalanceDown(
+        Storage.Layout storage $,
+        LoanState memory state,
+        uint256 currentCR,
+        uint256 targetCR
+    ) internal returns (uint256 ratio) {
+        uint256 collateralPriceUSD =
+            $.oracle.getAssetPrice(address($.assets.collateral));
+
+        uint8 collateralDecimals =
+            IERC20Metadata(address($.assets.collateral)).decimals();
+
+        // get offset caused by DEX fees + slippage
+        uint256 offsetFactor =
+            $.swapper.offsetFactor($.assets.collateral, $.assets.debt);
+
+        uint256 margin = mulDivDown(targetCR, $.ratioMargin, ONE_USD);
+        //uint256 margin = targetCR * $.ratioMargin / ONE_USD; // Munged by Certora
+        uint256 count;
+
+        do {
+            // current collateral ratio
+            ratio = currentCR;
+
+            uint256 collateralAmountAsset = RebalanceMath
+                .calculateCollateralAsset(
+                state,
+                RebalanceMath.requiredCollateralUSD(
+                    targetCR, state.collateralUSD, state.debtUSD, offsetFactor
+                ),
+                collateralPriceUSD,
+                collateralDecimals
+            );
+
+            if (collateralAmountAsset == 0) {
+                break;
+            }
+
+            uint256 borrowAmountAsset =
+                withdrawAndSwapCollateral($, collateralAmountAsset);
+
+            if (borrowAmountAsset == 0) {
+                break;
+            }
+
+            // repay debt to lending _pool
+            state =
+                LoanLogic.repay($.lendingPool, $.assets.debt, borrowAmountAsset);
+
+            // update collateral ratio value
+            ratio = RebalanceMath.collateralRatioUSD(
+                state.collateralUSD, state.debtUSD
+            );
+
+            if (++count > $.maxIterations) {
+                break;
+            }
+        } while (ratio + margin < targetCR);
+    }
+
+    /// @notice rebalances downwards until a debt amount is reached
+    /// @param $ the storage state of LendingStrategyStorage
+    /// @param state the strategy loan state information (collateralized asset, borrowed asset, current collateral, current debt)
+    /// @param targetDebtUSD target debt value in USD to reach
+    function rebalanceDownToDebt(
+        Storage.Layout storage $,
+        LoanState memory state,
+        uint256 targetDebtUSD
+    ) internal {
+        uint256 collateralPriceUSD =
+            $.oracle.getAssetPrice(address($.assets.collateral));
+
+        uint8 collateralDecimals =
+            IERC20Metadata(address($.assets.collateral)).decimals();
+
+        // get offset caused by DEX fees + slippage
+        uint256 offsetFactor =
+            $.swapper.offsetFactor($.assets.collateral, $.assets.debt);
+
+        uint256 remainingDebtUSD = state.debtUSD - targetDebtUSD;
+        uint256 count;
+
+        do {
+            uint256 collateralAmountAsset = RebalanceMath
+                .calculateCollateralAsset(
+                state,
+                mulDivDown(remainingDebtUSD, ONE_USD, (ONE_USD - offsetFactor)),
+                //remainingDebtUSD * ONE_USD / (ONE_USD - offsetFactor), // Munged by Certora
+                collateralPriceUSD,
+                collateralDecimals
+            );
+
+            if (collateralAmountAsset == 0) {
+                break;
+            }
+
+            uint256 borrowAmountAsset =
+                withdrawAndSwapCollateral($, collateralAmountAsset);
+
+            if (borrowAmountAsset == 0) {
+                break;
+            }
+
+            // repay debt to lending _pool
+            state =
+                LoanLogic.repay($.lendingPool, $.assets.debt, borrowAmountAsset);
+
+            remainingDebtUSD = state.debtUSD > targetDebtUSD
+                ? state.debtUSD - targetDebtUSD
+                : 0;
+
+            if (++count > $.maxIterations) {
+                break;
+            }
+        } while (targetDebtUSD < state.debtUSD);
+    }
+
+    /// @notice withrdraws an amount of collateral asset and exchanges it for an
+    /// amount of debt asset
+    /// @param $ the storage state of LendingStrategyStorage
+    /// @param collateralAmountAsset amount of collateral asset to withdraw and swap
+    /// @return borrowAmountAsset amount of borrow asset received from swap
+    function withdrawAndSwapCollateral(
+        Storage.Layout storage $,
+        uint256 collateralAmountAsset
+    ) internal returns (uint256 borrowAmountAsset) {
+        // withdraw collateral tokens from lending _pool
+        LoanLogic.withdraw(
+            $.lendingPool, $.assets.collateral, collateralAmountAsset
+        );
+
+        // approve swapper contract to swap asset
+        $.assets.collateral.approve(address($.swapper), collateralAmountAsset);
+
+        // exchange collateralAmount of collateral tokens for borrow tokens
+        return $.swapper.swap(
+            $.assets.collateral,
+            $.assets.debt,
+            collateralAmountAsset,
+            payable(address(this))
+        );
+    }
+
+    /// @dev returns if collateral ratio is out of the acceptable range and reabalance should happen
+    /// @param collateralRatio given collateral ratio
+    /// @param collateraRatioTargets struct which contain targets (min and max for rebalance)
+    function rebalanceNeeded(
+        uint256 collateralRatio,
+        CollateralRatio memory collateraRatioTargets
+    ) internal pure returns (bool) {
+        return (
+            collateralRatio < collateraRatioTargets.minForRebalance
+                || collateralRatio > collateraRatioTargets.maxForRebalance
+        );
+    }
+
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res) {
+            res = a * b / c;
+    }
+}
diff -ruN ../src/src/libraries/math/ConversionMath.sol src/libraries/math/ConversionMath.sol
--- ../src/src/libraries/math/ConversionMath.sol	1970-01-01 02:00:00
+++ src/libraries/math/ConversionMath.sol	2024-02-13 11:34:30
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { USDWadRayMath } from "./USDWadRayMath.sol";
+
+library ConversionMath {
+    using USDWadRayMath for uint256;
+
+    /// @dev decimals of USD prices as per oracle
+    uint8 internal constant USD_DECIMALS = 8;
+
+    /// @notice converts a asset amount to its usd value
+    /// @param assetAmount amount of asset
+    /// @param priceInUSD price of asset in USD
+    /// @return usdAmount amount of USD after conversion
+    function convertAssetToUSD(
+        uint256 assetAmount,
+        uint256 priceInUSD,
+        uint256 assetDecimals
+    ) internal pure returns (uint256 usdAmount) {
+        usdAmount = mulDivDown(assetAmount, priceInUSD, (10 ** assetDecimals));
+        // usdAmount = assetAmount * priceInUSD / (10 ** assetDecimals); // Munged by Certora
+    }
+
+    /// @notice converts a USD amount to its token value
+    /// @param usdAmount amount of USD
+    /// @param priceInUSD price of asset in USD
+    /// @return assetAmount amount of asset after conversion
+    function convertUSDToAsset(
+        uint256 usdAmount,
+        uint256 priceInUSD,
+        uint256 assetDecimals
+    ) internal pure returns (uint256 assetAmount) {
+        if (USD_DECIMALS > assetDecimals) {
+            assetAmount = mulDivDown(usdAmount.usdDiv(priceInUSD), 1,
+                (10 ** (USD_DECIMALS - assetDecimals)));
+        } else {
+            assetAmount = (mulDivDown(usdAmount, 10 ** (assetDecimals - USD_DECIMALS), 1))
+                .usdDiv(priceInUSD);
+        }
+        // if (USD_DECIMALS > assetDecimals) {
+        //     assetAmount = usdAmount.usdDiv(priceInUSD)
+        //         / (10 ** (USD_DECIMALS - assetDecimals)); // Munged by Certora
+        // } else {
+        //     assetAmount = (usdAmount * (10 ** (assetDecimals - USD_DECIMALS))) // Munged by Certora
+        //         .usdDiv(priceInUSD);
+        //}
+    }
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res) {
+            res = a * b / c;
+    }
+}
diff -ruN ../src/src/libraries/math/RebalanceMath.sol src/libraries/math/RebalanceMath.sol
--- ../src/src/libraries/math/RebalanceMath.sol	1970-01-01 02:00:00
+++ src/libraries/math/RebalanceMath.sol	2024-02-13 11:23:22
@@ -0,0 +1,117 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { ConversionMath } from "./ConversionMath.sol";
+import { USDWadRayMath } from "./USDWadRayMath.sol";
+import { LoanState } from "../../types/DataTypes.sol";
+
+library RebalanceMath {
+    using USDWadRayMath for uint256;
+
+    uint256 internal constant ONE_USD = 1e8;
+
+    /// @notice helper function to calculate collateral ratio
+    /// @param collateralUSD collateral value in USD
+    /// @param debtUSD debt valut in USD
+    /// @return ratio collateral ratio value
+    function collateralRatioUSD(uint256 collateralUSD, uint256 debtUSD)
+        internal
+        pure
+        returns (uint256 ratio)
+    {
+        ratio = debtUSD != 0 ? collateralUSD.usdDiv(debtUSD) : type(uint256).max;
+    }
+
+    /// @notice helper function to offset amounts by a USD percentage downwards
+    /// @param a amount to offset
+    /// @param offsetUSD offset as a number between 0 -  ONE_USD
+    function offsetUSDAmountDown(uint256 a, uint256 offsetUSD)
+        internal
+        pure
+        returns (uint256 amount)
+    {
+        // prevent overflows
+        if (a <= mulDivDown(type(uint256).max, 1, (ONE_USD - offsetUSD))) {
+            amount = mulDivDown(a, (ONE_USD - offsetUSD), ONE_USD);
+        } else {
+            amount = mulDivDown(mulDivDown(a, 1, ONE_USD), (ONE_USD - offsetUSD), 1);
+        }
+        // if (a <= type(uint256).max / (ONE_USD - offsetUSD)) { // Munged by Certora
+        //     amount = (a * (ONE_USD - offsetUSD)) / ONE_USD; // Munged by Certora
+        // } else {
+        //     amount = (a / ONE_USD) * (ONE_USD - offsetUSD); // Munged by Certora
+        // }
+    }
+
+    /// @notice calculates the total required borrow amount in order to reach a target collateral ratio value
+    /// @param targetCR target collateral ratio value
+    /// @param collateralUSD current collateral value in USD
+    /// @param debtUSD current debt value in USD
+    /// @param offsetFactor expected loss to DEX fees and slippage expressed as a value from 0 - ONE_USD
+    /// @return amount required borrow amount
+    function requiredBorrowUSD(
+        uint256 targetCR,
+        uint256 collateralUSD,
+        uint256 debtUSD,
+        uint256 offsetFactor
+    ) internal pure returns (uint256 amount) {
+        return (collateralUSD - targetCR.usdMul(debtUSD)).usdDiv(
+            targetCR - (ONE_USD - offsetFactor)
+        );
+    }
+
+    /// @notice calculates the total required collateral amount in order to reach a target collateral ratio value
+    /// @param targetCR target collateral ratio value
+    /// @param collateralUSD current collateral value in USD
+    /// @param debtUSD current debt value in USD
+    /// @param offsetFactor expected loss to DEX fees and slippage expressed as a value from 0 - ONE_USD
+    /// @return amount required collateral amount
+    function requiredCollateralUSD(
+        uint256 targetCR,
+        uint256 collateralUSD,
+        uint256 debtUSD,
+        uint256 offsetFactor
+    ) internal pure returns (uint256 amount) {
+        return (
+            amount = (targetCR.usdMul(debtUSD) - collateralUSD).usdDiv(
+                targetCR.usdMul(ONE_USD - offsetFactor) - ONE_USD
+            )
+        );
+    }
+
+    /// @notice determines the collateral asset amount needed for a rebalance down cycle
+    /// @param state loan state
+    /// @param neededCollateralUSD collateral needed for overall operation in USD
+    /// @param collateralPriceUSD price of collateral in USD
+    /// @param collateralDecimals decimals of collateral token
+    /// @return collateralAmountAsset amount of collateral asset needed fo the current rebalance down cycle
+    function calculateCollateralAsset(
+        LoanState memory state,
+        uint256 neededCollateralUSD,
+        uint256 collateralPriceUSD,
+        uint256 collateralDecimals
+    ) internal pure returns (uint256 collateralAmountAsset) {
+        // maximum amount of collateral to not jeopardize loan health in USD
+        uint256 collateralAmountUSD = state.maxWithdrawAmount;
+
+        // handle cases where debt is less than maxWithdrawAmount possible
+        if (state.debtUSD < state.maxWithdrawAmount) {
+            collateralAmountUSD = state.debtUSD;
+        }
+
+        // if less than the max collateral amount possible is needed,
+        // use the amount that is required to reach targetCR
+        collateralAmountUSD = collateralAmountUSD < neededCollateralUSD
+            ? collateralAmountUSD
+            : neededCollateralUSD;
+
+        return ConversionMath.convertUSDToAsset(
+            collateralAmountUSD, collateralPriceUSD, collateralDecimals
+        );
+    }
+
+    function mulDivDown(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 res) {
+            res = a * b / c;
+    }
+}
diff -ruN ../src/src/libraries/math/USDWadRayMath.sol src/libraries/math/USDWadRayMath.sol
--- ../src/src/libraries/math/USDWadRayMath.sol	1970-01-01 02:00:00
+++ src/libraries/math/USDWadRayMath.sol	2024-02-13 01:00:56
@@ -0,0 +1,204 @@
+// SPDX-License-Identifier: MIT
+
+pragma solidity ^0.8.21;
+
+/**
+ * @title WadRayMath library
+ * @author Aave
+ * @notice Provides functions to perform calculations with Wad and Ray units
+ * @dev Provides mul and div function for wads (decimal numbers with 18 digits of precision) and rays (decimal numbers
+ * with 27 digits of precision), and USDs (decimal numbers with 8 digits of precisions)
+ * @dev Operations are rounded. If a value is >=.5, will be rounded up, otherwise rounded down.
+ * @dev USD-related functionality added by Seamless
+ */
+library USDWadRayMath {
+    // HALF_WAD and HALF_RAY expressed with extended notation as constant with operations are not supported in Yul assembly
+    uint256 internal constant WAD = 1e18;
+    uint256 internal constant HALF_WAD = 0.5e18;
+
+    uint256 internal constant RAY = 1e27;
+    uint256 internal constant HALF_RAY = 0.5e27;
+
+    uint256 internal constant USD = 1e8;
+    uint256 internal constant HALF_USD = 0.5e8;
+
+    uint256 internal constant USD_WAD_RATIO = 1e10;
+    uint256 internal constant WAD_RAY_RATIO = 1e9;
+
+    /**
+     * @dev Multiplies two wad, rounding half up to the nearest wad
+     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+     * @param a Wad
+     * @param b Wad
+     * @return c = a*b, in wad
+     */
+    function wadMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
+        // to avoid overflow, a <= (type(uint256).max - HALF_WAD) / b
+        assembly {
+            if iszero(
+                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_WAD), b))))
+            ) { revert(0, 0) }
+
+            c := div(add(mul(a, b), HALF_WAD), WAD)
+        }
+    }
+
+    /// @dev Divides two USD, rounding half up to the nearest USD
+    /// @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+    /// @param a USD
+    /// @param b USD
+    /// @return c = a/b, in USD
+    function usdDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
+        // to avoid overflow, a <= (type(uint256).max - halfB) / USD
+        assembly {
+            if or(
+                iszero(b),
+                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), USD))))
+            ) { revert(0, 0) }
+
+            c := div(add(mul(a, USD), div(b, 2)), b)
+        }
+    }
+
+    function usdDivRoundDown(uint256 a, uint256 b)
+        internal
+        pure
+        returns (uint256 c)
+    {
+        // to avoid overflow, a <= (type(uint256).max - halfB) / USD
+        assembly {
+            if or(
+                iszero(b),
+                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), USD))))
+            ) { revert(0, 0) }
+
+            c := div(mul(a, USD), b)
+        }
+    }
+
+    /// @dev Multiplies two USD, rounding half up to the nearest USD
+    /// @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+    /// @param a USD
+    /// @param b USD
+    /// @return c = a*b, in USD
+    function usdMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
+        // to avoid overflow, a <= (type(uint256).max - HALF_USD) / b
+        assembly {
+            if iszero(
+                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_USD), b))))
+            ) { revert(0, 0) }
+
+            c := div(add(mul(a, b), HALF_USD), USD)
+        }
+    }
+
+    /**
+     * @dev Divides two wad, rounding half up to the nearest wad
+     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+     * @param a Wad
+     * @param b Wad
+     * @return c = a/b, in wad
+     */
+    function wadDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
+        // to avoid overflow, a <= (type(uint256).max - halfB) / WAD
+        assembly {
+            if or(
+                iszero(b),
+                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), WAD))))
+            ) { revert(0, 0) }
+
+            c := div(add(mul(a, WAD), div(b, 2)), b)
+        }
+    }
+
+    /**
+     * @notice Multiplies two ray, rounding half up to the nearest ray
+     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+     * @param a Ray
+     * @param b Ray
+     * @return c = a raymul b
+     */
+    function rayMul(uint256 a, uint256 b) internal pure returns (uint256 c) {
+        // to avoid overflow, a <= (type(uint256).max - HALF_RAY) / b
+        assembly {
+            if iszero(
+                or(iszero(b), iszero(gt(a, div(sub(not(0), HALF_RAY), b))))
+            ) { revert(0, 0) }
+
+            c := div(add(mul(a, b), HALF_RAY), RAY)
+        }
+    }
+
+    /**
+     * @notice Divides two ray, rounding half up to the nearest ray
+     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+     * @param a Ray
+     * @param b Ray
+     * @return c = a raydiv b
+     */
+    function rayDiv(uint256 a, uint256 b) internal pure returns (uint256 c) {
+        // to avoid overflow, a <= (type(uint256).max - halfB) / RAY
+        assembly {
+            if or(
+                iszero(b),
+                iszero(iszero(gt(a, div(sub(not(0), div(b, 2)), RAY))))
+            ) { revert(0, 0) }
+
+            c := div(add(mul(a, RAY), div(b, 2)), b)
+        }
+    }
+
+    /**
+     * @dev Casts ray down to wad
+     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+     * @param a Ray
+     * @return b = a converted to wad, rounded half up to the nearest wad
+     */
+    function rayToWad(uint256 a) internal pure returns (uint256 b) {
+        assembly {
+            b := div(a, WAD_RAY_RATIO)
+            let remainder := mod(a, WAD_RAY_RATIO)
+            if iszero(lt(remainder, div(WAD_RAY_RATIO, 2))) { b := add(b, 1) }
+        }
+    }
+
+    /**
+     * @dev Converts wad up to ray
+     * @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+     * @param a Wad
+     * @return b = a converted in ray
+     */
+    function wadToRay(uint256 a) internal pure returns (uint256 b) {
+        // to avoid overflow, b/WAD_RAY_RATIO == a
+        assembly {
+            b := mul(a, WAD_RAY_RATIO)
+
+            if iszero(eq(div(b, WAD_RAY_RATIO), a)) { revert(0, 0) }
+        }
+    }
+
+    /// @dev Casts wad down to USD
+    /// @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+    /// @param a Wad
+    /// @return b = a converted to USD, rounded half up to the nearest USD
+    function wadToUSD(uint256 a) internal pure returns (uint256 b) {
+        assembly {
+            b := div(a, USD_WAD_RATIO)
+            let remainder := mod(a, USD_WAD_RATIO)
+            if iszero(lt(remainder, div(USD_WAD_RATIO, 2))) { b := add(b, 1) }
+        }
+    }
+
+    /// @dev Converts USD up to Wad
+    /// @dev assembly optimized for improved gas savings, see https://twitter.com/transmissions11/status/1451131036377571328
+    /// @param a USD
+    /// @return b = a converted in wad
+    function usdToWad(uint256 a) internal pure returns (uint256 b) {
+        // to avoid overflow, b/USD_WAD_RATIO == a
+        assembly {
+            b := mul(a, USD_WAD_RATIO)
+
+            if iszero(eq(div(b, USD_WAD_RATIO), a)) { revert(0, 0) }
+        }
+    }
+}
diff -ruN ../src/src/storage/AerodromeAdapterStorage.sol src/storage/AerodromeAdapterStorage.sol
--- ../src/src/storage/AerodromeAdapterStorage.sol	1970-01-01 02:00:00
+++ src/storage/AerodromeAdapterStorage.sol	2024-02-13 01:00:56
@@ -0,0 +1,31 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { IRouter } from "../vendor/aerodrome/IRouter.sol";
+
+library AerodromeAdapterStorage {
+    /// @dev struct containing all state for the AerodromeAdapter contract
+    /// @custom:storage-location erc7201:seamless.contracts.storage.AerodromeAdapter
+    struct Layout {
+        mapping(IERC20 from => mapping(IERC20 to => IRouter.Route[] routes))
+            swapRoutes;
+        mapping(IERC20 from => mapping(IERC20 to => bool isStable)) isPoolStable;
+        mapping(address pair => address factory) pairFactory;
+        address router;
+        address poolFactory;
+    }
+
+    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.AerodromeAdapter")) - 1)) & ~bytes32(uint256(0xff));
+    bytes32 internal constant STORAGE_SLOT =
+        0xe20fadfe51c05810cf8049153a6d3327f8bd31f8cadde6b0efd76ce5573f2600;
+
+    function layout() internal pure returns (Layout storage l) {
+        bytes32 slot = STORAGE_SLOT;
+        assembly {
+            l.slot := slot
+        }
+    }
+}
diff -ruN ../src/src/storage/LoopStrategyStorage.sol src/storage/LoopStrategyStorage.sol
--- ../src/src/storage/LoopStrategyStorage.sol	1970-01-01 02:00:00
+++ src/storage/LoopStrategyStorage.sol	2024-02-13 01:00:56
@@ -0,0 +1,53 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import {
+    CollateralRatio,
+    StrategyAssets,
+    LendingPool
+} from "../types/DataTypes.sol";
+import { IPoolAddressesProvider } from
+    "@aave/contracts/interfaces/IPoolAddressesProvider.sol";
+import { IPool } from "@aave/contracts/interfaces/IPool.sol";
+import { IPriceOracleGetter } from
+    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
+import { ISwapper } from "../interfaces/ISwapper.sol";
+
+library LoopStrategyStorage {
+    /// @dev struct containing all state for the LoopStrategy contract
+    /// @custom:storage-location erc7201:seamless.contracts.storage.LoopStrategy
+    struct Layout {
+        /// @dev struct encapsulating collateral and borrow asset addresses
+        StrategyAssets assets;
+        /// @dev struct encapsulating min/max bounds and target values for the collateral ratio
+        CollateralRatio collateralRatioTargets;
+        /// @dev error margin on specific target collateral ratio passed in function calls
+        uint256 ratioMargin;
+        /// @dev acceptable error margin on usd values - a value from 0 - ONE_USD
+        uint256 usdMargin;
+        /// @dev pool address provider for the Seamles Protocol lending pools
+        IPoolAddressesProvider poolAddressProvider;
+        /// @dev struct encapsulating address of the lending pool and configuration (interest rate mode)
+        LendingPool lendingPool;
+        /// @dev price oracle address
+        IPriceOracleGetter oracle;
+        /// @dev swapper address
+        ISwapper swapper;
+        /// @dev maximum amount of loop iterations when rebalancing
+        uint16 maxIterations;
+        /// @dev maximum amount total assets (total equity) of the strategy
+        uint256 assetsCap;
+    }
+
+    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.LoopStrategy")) - 1)) & ~bytes32(uint256(0xff));
+    bytes32 internal constant STORAGE_SLOT =
+        0x324C4071AA3926AF75895CE4C01A62A23C8476ED82CD28BA23ABB8C0F6634B00;
+
+    function layout() internal pure returns (Layout storage l) {
+        bytes32 slot = STORAGE_SLOT;
+        assembly {
+            l.slot := slot
+        }
+    }
+}
diff -ruN ../src/src/storage/SwapAdapterBaseStorage.sol src/storage/SwapAdapterBaseStorage.sol
--- ../src/src/storage/SwapAdapterBaseStorage.sol	1970-01-01 02:00:00
+++ src/storage/SwapAdapterBaseStorage.sol	2024-02-13 01:00:56
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+library SwapAdapterBaseStorage {
+    /// @dev struct containing all state for the SwapAdapterBase contract
+    /// @custom:storage-location erc7201:seamless.contracts.storage.SwapAdapterBase
+    struct Layout {
+        address swapper;
+    }
+
+    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.SwapAdapterBase")) - 1)) & ~bytes32(uint256(0xff));
+    bytes32 internal constant STORAGE_SLOT =
+        0xebbcbb6f4bc0510bac5105d82440cb1f3fa3634785f911c43618c35177456000;
+
+    function layout() internal pure returns (Layout storage l) {
+        bytes32 slot = STORAGE_SLOT;
+        assembly {
+            l.slot := slot
+        }
+    }
+}
diff -ruN ../src/src/storage/SwapperStorage.sol src/storage/SwapperStorage.sol
--- ../src/src/storage/SwapperStorage.sol	1970-01-01 02:00:00
+++ src/storage/SwapperStorage.sol	2024-02-13 01:00:56
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IPriceOracleGetter } from
+    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { Step } from "../types/DataTypes.sol";
+
+library SwapperStorage {
+    /// @dev struct containing all state for the Swapper contract
+    /// @custom:storage-location erc7201:seamless.contracts.storage.Swapper
+    struct Layout {
+        mapping(IERC20 from => mapping(IERC20 to => uint256 offsetUSD))
+            offsetUSD;
+        mapping(IERC20 from => mapping(IERC20 to => Step[] steps)) route;
+        uint256 offsetDeviationUSD;
+        IPriceOracleGetter oracle;
+    }
+
+    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.Swapper")) - 1)) & ~bytes32(uint256(0xff));
+    bytes32 internal constant STORAGE_SLOT =
+        0xd13913e6f5971fa78083bb454f0bd9d937359fbaf7a5296aa0498a9631cf8b00;
+
+    function layout() internal pure returns (Layout storage l) {
+        bytes32 slot = STORAGE_SLOT;
+        assembly {
+            l.slot := slot
+        }
+    }
+}
diff -ruN ../src/src/storage/WrappedTokenAdapterStorage.sol src/storage/WrappedTokenAdapterStorage.sol
--- ../src/src/storage/WrappedTokenAdapterStorage.sol	1970-01-01 02:00:00
+++ src/storage/WrappedTokenAdapterStorage.sol	2024-02-13 01:00:56
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { IWrappedERC20PermissionedDeposit } from
+    "../interfaces/IWrappedERC20PermissionedDeposit.sol";
+
+library WrappedTokenAdapterStorage {
+    /// @dev struct containing all state for the WrappedTokenAdapter contract
+    /// @custom:storage-location erc7201:seamless.contracts.storage.WrappedTokenAdapter
+    struct Layout {
+        mapping(
+            IERC20 from
+                => mapping(
+                    IERC20 to => IWrappedERC20PermissionedDeposit wrapper
+                )
+            ) wrappers;
+    }
+
+    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.WrappedTokenAdapter")) - 1)) & ~bytes32(uint256(0xff));
+    bytes32 internal constant STORAGE_SLOT =
+        0x25b70c849dde52d8ddadc20d855caa6e4102bdc5328ba5593a0d5c3e9ab8af00;
+
+    function layout() internal pure returns (Layout storage l) {
+        bytes32 slot = STORAGE_SLOT;
+        assembly {
+            l.slot := slot
+        }
+    }
+}
diff -ruN ../src/src/swap/Swapper.sol src/swap/Swapper.sol
--- ../src/src/swap/Swapper.sol	1970-01-01 02:00:00
+++ src/swap/Swapper.sol	2024-02-13 01:00:56
@@ -0,0 +1,250 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IPriceOracleGetter } from
+    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
+import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+import { IERC20Metadata } from
+    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
+import { SafeERC20 } from
+    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+
+import { ConversionMath } from "../libraries/math/ConversionMath.sol";
+import { ISwapper } from "../interfaces/ISwapper.sol";
+import { USDWadRayMath } from "../libraries/math/USDWadRayMath.sol";
+import { SwapperStorage as Storage } from "../storage/SwapperStorage.sol";
+import { Step } from "../types/DataTypes.sol";
+import { AccessControlUpgradeable } from
+    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
+import { UUPSUpgradeable } from
+    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
+
+/// @title Swapper
+/// @notice Routing contract for swaps across different DEXs
+contract Swapper is ISwapper, AccessControlUpgradeable, UUPSUpgradeable {
+    using USDWadRayMath for uint256;
+
+    /// @dev role which can use the swap function, only given to ILM strategies
+    bytes32 public constant STRATEGY_ROLE = keccak256("STRATEGY_ROLE");
+    /// @dev role which can change routes and offset factor
+    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
+    /// @dev role which can upgrade the contract
+    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
+
+    constructor() {
+        _disableInitializers();
+    }
+
+    /// @dev initializer function for Swapper contract
+    function Swapper_init(
+        address initialAdmin,
+        IPriceOracleGetter oracle,
+        uint256 offsetDeviationUSD
+    ) external initializer {
+        __AccessControl_init();
+        __UUPSUpgradeable_init();
+        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);
+
+        Storage.Layout storage $ = Storage.layout();
+        $.oracle = oracle;
+        $.offsetDeviationUSD = offsetDeviationUSD;
+    }
+
+    /// @inheritdoc UUPSUpgradeable
+    function _authorizeUpgrade(address)
+        internal
+        override
+        onlyRole(UPGRADER_ROLE)
+    { }
+
+    /// @inheritdoc ISwapper
+    function setRoute(IERC20 from, IERC20 to, Step[] calldata steps)
+        external
+        onlyRole(MANAGER_ROLE)
+    {
+        Storage.Layout storage $ = Storage.layout();
+
+        // remove route if it exists
+        if ($.route[from][to].length != 0) {
+            _removeRoute(from, to);
+        }
+
+        for (uint256 i; i < steps.length; ++i) {
+            if (address(steps[i].adapter) == address(0)) {
+                revert InvalidAddress();
+            }
+
+            $.route[from][to].push(steps[i]);
+        }
+
+        emit RouteSet(from, to, steps);
+    }
+
+    /// @inheritdoc ISwapper
+    function removeRoute(IERC20 from, IERC20 to)
+        external
+        onlyRole(MANAGER_ROLE)
+    {
+        _removeRoute(from, to);
+    }
+
+    /// @inheritdoc ISwapper
+    function setOffsetFactor(IERC20 from, IERC20 to, uint256 offsetUSD)
+        external
+        onlyRole(MANAGER_ROLE)
+    {
+        if (offsetUSD == 0 || offsetUSD > USDWadRayMath.USD) {
+            revert USDValueOutsideRange();
+        }
+
+        Storage.layout().offsetUSD[from][to] = offsetUSD;
+
+        emit OffsetFactorSet(from, to, offsetUSD);
+    }
+
+    /// @inheritdoc ISwapper
+    function setOracle(IPriceOracleGetter oracle)
+        external
+        onlyRole(MANAGER_ROLE)
+    {
+        Storage.layout().oracle = oracle;
+
+        emit OracleSet(oracle);
+    }
+
+    /// @inheritdoc ISwapper
+    function setOffsetDeviationUSD(uint256 offsetDeviationUSD)
+        external
+        onlyRole(MANAGER_ROLE)
+    {
+        if (offsetDeviationUSD > USDWadRayMath.USD) {
+            revert USDValueOutsideRange();
+        }
+
+        Storage.layout().offsetDeviationUSD = offsetDeviationUSD;
+
+        emit OffsetDeviationSet(offsetDeviationUSD);
+    }
+
+    /// @inheritdoc ISwapper
+    function swap(
+        IERC20 from,
+        IERC20 to,
+        uint256 fromAmount,
+        address payable beneficiary
+    ) external onlyRole(STRATEGY_ROLE) returns (uint256 toAmount) {
+        Step[] memory steps = Storage.layout().route[from][to];
+
+        uint256 initialAmount = fromAmount;
+
+        from.transferFrom(msg.sender, address(this), fromAmount);
+
+        // execute the swap for each swap-step in the route,
+        // updating `fromAmount` to be the amount received from
+        // each step
+        for (uint256 i; i < steps.length; ++i) {
+            steps[i].from.approve(address(steps[i].adapter), fromAmount);
+
+            // should handle address(0) cases ie for ETH?
+            fromAmount = steps[i].adapter.executeSwap(
+                steps[i].from, steps[i].to, fromAmount, payable(address(this))
+            );
+        }
+
+        // set the received amount as the amount received from the final
+        // step of the route
+        toAmount = fromAmount;
+
+        _enforceSlippageLimit(from, to, initialAmount, toAmount);
+
+        to.transfer(beneficiary, toAmount);
+    }
+
+    /// @inheritdoc ISwapper
+    function getOffsetDeviationUSD()
+        external
+        view
+        returns (uint256 offsetDeviationUSD)
+    {
+        return Storage.layout().offsetDeviationUSD;
+    }
+
+    /// @inheritdoc ISwapper
+    function getOracle() external view returns (IPriceOracleGetter oracle) {
+        return Storage.layout().oracle;
+    }
+
+    /// @inheritdoc ISwapper
+    function getRoute(IERC20 from, IERC20 to)
+        external
+        view
+        returns (Step[] memory steps)
+    {
+        return Storage.layout().route[from][to];
+    }
+
+    /// @inheritdoc ISwapper
+    function offsetFactor(IERC20 from, IERC20 to)
+        external
+        view
+        returns (uint256 offsetUSD)
+    {
+        return Storage.layout().offsetUSD[from][to];
+    }
+
+    /// @notice deletes an existing route
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    function _removeRoute(IERC20 from, IERC20 to) internal {
+        delete Storage.layout().route[from][to];
+
+        emit RouteRemoved(from, to);
+    }
+
+    /// @notice enforces the maximum slippage allowed for a given swap
+    /// @param from address of starting token
+    /// @param to address of ending token
+    /// @param fromAmount amount being swapped
+    /// @param toAmount amount received
+    function _enforceSlippageLimit(
+        IERC20 from,
+        IERC20 to,
+        uint256 fromAmount,
+        uint256 toAmount
+    ) internal view {
+        Storage.Layout storage $ = Storage.layout();
+        IPriceOracleGetter oracle = $.oracle;
+
+        // convert to/from amount to dollars
+        uint256 fromAmountUSD = ConversionMath.convertAssetToUSD(
+            fromAmount,
+            oracle.getAssetPrice(address(from)),
+            IERC20Metadata(address(from)).decimals()
+        );
+        uint256 toAmountUSD = ConversionMath.convertAssetToUSD(
+            toAmount,
+            oracle.getAssetPrice(address(to)),
+            IERC20Metadata(address(to)).decimals()
+        );
+
+        uint256 offsetUSD = $.offsetUSD[from][to];
+        uint256 maxDeviationUSD =
+            offsetUSD.usdMul($.offsetDeviationUSD).usdDiv(USDWadRayMath.USD);
+
+        // ensure these amounts do not differ by more than given slippage
+        uint256 maxSlippageUSD = fromAmountUSD.usdMul(
+            offsetUSD + maxDeviationUSD
+        ).usdDiv(USDWadRayMath.USD);
+        
+        // for the very low amounts allow 1 wei of slippage
+        if (maxSlippageUSD == 0) {
+            maxSlippageUSD = 1;
+        }
+
+        if (fromAmountUSD - maxSlippageUSD > toAmountUSD) {
+            revert MaxSlippageExceeded();
+        }
+    }
+}
\ No newline at end of file
diff -ruN ../src/src/swap/adapter/AerodromeAdapter.sol src/swap/adapter/AerodromeAdapter.sol
--- ../src/src/swap/adapter/AerodromeAdapter.sol	1970-01-01 02:00:00
+++ src/swap/adapter/AerodromeAdapter.sol	2024-02-13 01:00:56
@@ -0,0 +1,169 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { SwapAdapterBase } from "./SwapAdapterBase.sol";
+import { IAerodromeAdapter } from "../../interfaces/IAerodromeAdapter.sol";
+import { ISwapAdapter } from "../../interfaces/ISwapAdapter.sol";
+import { AerodromeAdapterStorage as Storage } from
+    "../../storage/AerodromeAdapterStorage.sol";
+import { SwapAdapterBaseStorage as BaseStorage } from
+    "../../storage/SwapAdapterBaseStorage.sol";
+import { IPoolFactory } from "../../vendor/aerodrome/IPoolFactory.sol";
+import { IRouter } from "../../vendor/aerodrome/IRouter.sol";
+
+/// @title AerodromeAdapter
+/// @notice Adapter contract for executing swaps on aerodrome
+contract AerodromeAdapter is SwapAdapterBase, IAerodromeAdapter {
+    /// @inheritdoc IAerodromeAdapter
+    function AerodromeAdapter__Init(
+        address owner,
+        address router,
+        address factory,
+        address swapper
+    ) external initializer {
+        __Ownable_init(owner);
+
+        Storage.Layout storage $ = Storage.layout();
+        $.router = router;
+        $.poolFactory = factory;
+
+        BaseStorage.layout().swapper = swapper;
+    }
+
+    /// @inheritdoc ISwapAdapter
+    function executeSwap(
+        IERC20 from,
+        IERC20 to,
+        uint256 fromAmount,
+        address payable beneficiary
+    ) external onlySwapper returns (uint256 toAmount) {
+        return _executeSwap(from, to, fromAmount, beneficiary);
+    }
+
+    /// @inheritdoc IAerodromeAdapter
+    function setIsPoolStable(IERC20 from, IERC20 to, bool status)
+        external
+        onlyOwner
+    {
+        Storage.layout().isPoolStable[from][to] = status;
+
+        emit IsPoolStableSet(from, to, status);
+    }
+
+    /// @inheritdoc IAerodromeAdapter
+    function setPoolFactory(address factory) external onlyOwner {
+        Storage.layout().poolFactory = factory;
+
+        emit PoolFactorySet(factory);
+    }
+
+    /// @inheritdoc IAerodromeAdapter
+    function setRouter(address router) external onlyOwner {
+        Storage.layout().router = router;
+
+        emit RouterSet(router);
+    }
+
+    /// @inheritdoc IAerodromeAdapter
+    function setRoutes(IERC20 from, IERC20 to, IRouter.Route[] memory routes)
+        external
+        onlyOwner
+    {
+        Storage.Layout storage $ = Storage.layout();
+
+        if ($.swapRoutes[from][to].length != 0) {
+            _removeRoutes(from, to);
+        }
+
+        for (uint256 i; i < routes.length; ++i) {
+            $.swapRoutes[from][to].push(routes[i]);
+        }
+
+        emit RoutesSet(from, to, routes);
+    }
+
+    /// @inheritdoc IAerodromeAdapter
+    function removeRoutes(IERC20 from, IERC20 to) external onlyOwner {
+        _removeRoutes(from, to);
+    }
+
+    /// @inheritdoc ISwapAdapter
+    function setSwapper(address swapper) external onlyOwner {
+        _setSwapper(swapper);
+    }
+
+    /// @inheritdoc ISwapAdapter
+    function getSwapper() external view returns (address swapper) {
+        return _getSwapper();
+    }
+
+    /// @inheritdoc IAerodromeAdapter
+    function getIsPoolStable(IERC20 from, IERC20 to)
+        external
+        view
+        returns (bool status)
+    {
+        return Storage.layout().isPoolStable[from][to];
+    }
+
+    /// @inheritdoc IAerodromeAdapter
+    function getPoolFactory() external view returns (address factory) {
+        return Storage.layout().poolFactory;
+    }
+
+    //// @inheritdoc IAerodromeAdapter
+    function getRouter() external view returns (address router) {
+        return Storage.layout().router;
+    }
+
+    //// @inheritdoc IAerodromeAdapter
+    function getSwapRoutes(IERC20 from, IERC20 to)
+        external
+        view
+        returns (IRouter.Route[] memory routes)
+    {
+        return Storage.layout().swapRoutes[from][to];
+    }
+
+    /// @notice deletes existing routes for a given swap
+    /// @param from address of token route ends with
+    /// @param to address of token route starts with
+    function _removeRoutes(IERC20 from, IERC20 to) internal {
+        delete Storage.layout().swapRoutes[from][to];
+
+        emit RoutesRemoved(from, to);
+    }
+
+    /// @notice swaps a given amount of a token to another token, sending the final amount to the beneficiary
+    /// @dev overridden internal _executeSwap function from SwapAdapterBase contract
+    /// @param from address of token to swap from
+    /// @param to address of token to swap to
+    /// @param fromAmount amount of from token to swap
+    /// @param beneficiary receiver of final to token amount
+    /// @return toAmount amount of to token returned from swapping
+    function _executeSwap(
+        IERC20 from,
+        IERC20 to,
+        uint256 fromAmount,
+        address payable beneficiary
+    ) internal override returns (uint256 toAmount) {
+        Storage.Layout storage $ = Storage.layout();
+
+        from.transferFrom(msg.sender, address(this), fromAmount);
+
+        from.approve($.router, fromAmount);
+
+        uint256[] memory toAmounts = IRouter($.router).swapExactTokensForTokens(
+            fromAmount,
+            0,
+            $.swapRoutes[from][to],
+            beneficiary,
+            block.timestamp + 10
+        );
+
+        toAmount = toAmounts[toAmounts.length - 1];
+    }
+}
diff -ruN ../src/src/swap/adapter/SwapAdapterBase.sol src/swap/adapter/SwapAdapterBase.sol
--- ../src/src/swap/adapter/SwapAdapterBase.sol	1970-01-01 02:00:00
+++ src/swap/adapter/SwapAdapterBase.sol	2024-02-13 01:00:56
@@ -0,0 +1,54 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import {
+    Ownable2StepUpgradeable,
+    OwnableUpgradeable
+} from "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { ISwapAdapter } from "../../interfaces/ISwapAdapter.sol";
+import { SwapAdapterBaseStorage as Storage } from
+    "../../storage/SwapAdapterBaseStorage.sol";
+
+/// @title SwapAdapterBase
+/// @notice Base adapter contract for all swap adapters
+/// @dev should be inherited and overridden by all SwapAdapter implementations
+abstract contract SwapAdapterBase is Ownable2StepUpgradeable, ISwapAdapter {
+    modifier onlySwapper() {
+        if (Storage.layout().swapper != msg.sender) {
+            revert NotSwapper();
+        }
+        _;
+    }
+
+    /// @notice swaps a given amount of a token to another token, sending the final amount to the beneficiary
+    /// @param from address of token to swap from
+    /// @param to address of token to swap to
+    /// @param fromAmount amount of from token to swap
+    /// @param beneficiary receiver of final to token amount
+    /// @return toAmount amount of to token returned from swapping
+    function _executeSwap(
+        IERC20 from,
+        IERC20 to,
+        uint256 fromAmount,
+        address payable beneficiary
+    ) internal virtual returns (uint256 toAmount) {
+        // override with adapter specific swap logic
+    }
+
+    /// @notice returns the address of Swapper contract
+    /// @return swapper address of Swapper contract
+    function _getSwapper() internal view virtual returns (address swapper) {
+        return Storage.layout().swapper;
+    }
+
+    /// @notice sets the address of the Swapper contract
+    /// @param swapper address of Swapper contract
+    function _setSwapper(address swapper) internal virtual {
+        Storage.layout().swapper = swapper;
+
+        emit SwapperSet(swapper);
+    }
+}
diff -ruN ../src/src/swap/adapter/WrappedTokenAdapter.sol src/swap/adapter/WrappedTokenAdapter.sol
--- ../src/src/swap/adapter/WrappedTokenAdapter.sol	1970-01-01 02:00:00
+++ src/swap/adapter/WrappedTokenAdapter.sol	2024-02-13 01:00:56
@@ -0,0 +1,122 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { SwapAdapterBase } from "./SwapAdapterBase.sol";
+import { ISwapAdapter } from "../../interfaces/ISwapAdapter.sol";
+import { WrappedTokenAdapterStorage as Storage } from
+    "../../storage/WrappedTokenAdapterStorage.sol";
+import { SwapAdapterBaseStorage as BaseStorage } from
+    "../../storage/SwapAdapterBaseStorage.sol";
+import { IWrappedERC20PermissionedDeposit } from
+    "../../interfaces/IWrappedERC20PermissionedDeposit.sol";
+import { IWrappedTokenAdapter } from "../../interfaces/IWrappedTokenAdapter.sol";
+
+/// @title WrappedTokenAdapter
+/// @notice Adapter contract for executing swaps on aerodrome
+contract WrappedTokenAdapter is SwapAdapterBase, IWrappedTokenAdapter {
+    /// @notice emitted when the wrapper contract for a given WrappedToken is set
+    /// @param from token to perform wrapping/unwrapping on
+    /// @param to token which will be received after wrapping/unwrapping
+    /// @param wrapper WrappedERC20PermissionedDeposit contract
+    event WrapperSet(
+        IERC20 from, IERC20 to, IWrappedERC20PermissionedDeposit wrapper
+    );
+
+    /// @notice emitted when the wrapper contract for a given WrappedToken is removed
+    /// @param from token to perform wrapping/unwrapping on
+    /// @param to token which will be received after wrapping/unwrapping
+    event WrapperRemoved(IERC20 from, IERC20 to);
+
+    /// @inheritdoc IWrappedTokenAdapter
+    function WrappedTokenAdapter__Init(address owner, address swapper)
+        external
+        initializer
+    {
+        __Ownable_init(owner);
+        BaseStorage.layout().swapper = swapper;
+    }
+
+    /// @inheritdoc ISwapAdapter
+    function executeSwap(
+        IERC20 from,
+        IERC20 to,
+        uint256 fromAmount,
+        address payable beneficiary
+    ) external onlySwapper returns (uint256 toAmount) {
+        Storage.Layout storage $ = Storage.layout();
+
+        from.transferFrom(msg.sender, address(this), fromAmount);
+
+        IWrappedERC20PermissionedDeposit wrapper = $.wrappers[from][to];
+
+        from.approve(address(wrapper), fromAmount);
+
+        if (address(wrapper.underlying()) == address(to)) {
+            wrapper.withdraw(fromAmount);
+        } else {
+            wrapper.deposit(fromAmount);
+        }
+
+        to.transfer(address(beneficiary), fromAmount);
+
+        // should always be 1:1 ratio
+        return fromAmount;
+    }
+
+    /// @inheritdoc ISwapAdapter
+    function setSwapper(address swapper) external onlyOwner {
+        _setSwapper(swapper);
+    }
+
+    /// @inheritdoc IWrappedTokenAdapter
+    function setWrapper(
+        IERC20 from,
+        IERC20 to,
+        IWrappedERC20PermissionedDeposit wrapper
+    ) external onlyOwner {
+        Storage.Layout storage $ = Storage.layout();
+
+        if (address($.wrappers[from][to]) != address(0)) {
+            _removeWrapper(from, to);
+        }
+
+        $.wrappers[from][to] = wrapper;
+        $.wrappers[to][from] = wrapper;
+
+        emit WrapperSet(from, to, wrapper);
+        emit WrapperSet(to, from, wrapper);
+    }
+
+    /// @inheritdoc IWrappedTokenAdapter
+    function removeWrapper(IERC20 from, IERC20 to) external onlyOwner {
+        _removeWrapper(from, to);
+    }
+
+    /// @inheritdoc IWrappedTokenAdapter
+    function getWrapper(IERC20 from, IERC20 to)
+        external
+        view
+        returns (IWrappedERC20PermissionedDeposit wrapper)
+    {
+        return Storage.layout().wrappers[from][to];
+    }
+
+    /// @inheritdoc ISwapAdapter
+    function getSwapper() external view returns (address swapper) {
+        return _getSwapper();
+    }
+
+    /// @notice removes a previously set wrapper for a given from/to token pair
+    /// @param from token to wrap/unwrap
+    /// @param to token received after wrapping/unwrapping
+    function _removeWrapper(IERC20 from, IERC20 to) internal {
+        delete Storage.layout().wrappers[from][to];
+        delete Storage.layout().wrappers[to][from];
+
+        emit WrapperRemoved(from, to);
+        emit WrapperRemoved(to, from);
+    }
+}
diff -ruN ../src/src/tokens/WrappedCbETH.sol src/tokens/WrappedCbETH.sol
--- ../src/src/tokens/WrappedCbETH.sol	1970-01-01 02:00:00
+++ src/tokens/WrappedCbETH.sol	2024-02-13 01:00:56
@@ -0,0 +1,80 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import {
+    Ownable,
+    Ownable2Step
+} from "@openzeppelin/contracts/access/Ownable2Step.sol";
+import { ERC20, IERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
+import { SafeERC20 } from
+    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
+
+import { IWrappedERC20PermissionedDeposit } from
+    "../interfaces/IWrappedERC20PermissionedDeposit.sol";
+
+/// @title WrappedCbETH
+/// @notice contract used to wrap underlying ERC20 token and mints the same amount of a wrapped token.
+/// @notice this contract will be used to mainly to wrap cbETH and use it as a collateral in the lending pool
+/// @notice but only strategies contracts will be able to get wrapped token it and borrow against it.
+contract WrappedCbETH is
+    IWrappedERC20PermissionedDeposit,
+    ERC20,
+    Ownable2Step
+{
+    /// @notice address of the underlying token which is wrapped
+    IERC20 public immutable underlying;
+
+    /// @notice map shows if address has pemission to wrap tokens
+    mapping(address => bool) public depositor;
+
+    modifier onlyDepositors() {
+        if (!depositor[msg.sender]) {
+            revert NotDepositor(msg.sender);
+        }
+        _;
+    }
+
+    constructor(
+        string memory _name,
+        string memory _symbol,
+        IERC20 _underlyingToken,
+        address _initialOwner
+    ) ERC20(_name, _symbol) Ownable(_initialOwner) {
+        underlying = _underlyingToken;
+    }
+
+    /// @inheritdoc IWrappedERC20PermissionedDeposit
+    function deposit(uint256 amount) external override onlyDepositors {
+        SafeERC20.safeTransferFrom(
+            underlying, msg.sender, address(this), amount
+        );
+        _mint(msg.sender, amount);
+        emit Deposit(msg.sender, amount);
+    }
+
+    /// @inheritdoc IWrappedERC20PermissionedDeposit
+    function withdraw(uint256 amount) external override {
+        _burn(msg.sender, amount);
+        SafeERC20.safeTransfer(underlying, msg.sender, amount);
+        emit Withdraw(msg.sender, amount);
+    }
+
+    /// @inheritdoc IWrappedERC20PermissionedDeposit
+    function setDepositPermission(address account, bool toSet)
+        external
+        override
+        onlyOwner
+    {
+        depositor[account] = toSet;
+        emit SetDepositPermission(account, toSet);
+    }
+
+    /// @inheritdoc IWrappedERC20PermissionedDeposit
+    function recover() external override onlyOwner {
+        uint256 amountSurplus =
+            underlying.balanceOf(address(this)) - totalSupply();
+        SafeERC20.safeTransfer(underlying, msg.sender, amountSurplus);
+        emit RecoverUnderlyingSurplus(msg.sender, amountSurplus);
+    }
+}
diff -ruN ../src/src/types/DataTypes.sol src/types/DataTypes.sol
--- ../src/src/types/DataTypes.sol	1970-01-01 02:00:00
+++ src/types/DataTypes.sol	2024-02-13 01:00:56
@@ -0,0 +1,74 @@
+// SPDX-License-Identifier: BUSL-1.1
+
+pragma solidity ^0.8.21;
+
+import { IPool } from "@aave/contracts/interfaces/IPool.sol";
+import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
+
+import { ISwapAdapter } from "../interfaces/ISwapAdapter.sol";
+
+/// @title DataTypes
+/// @notice Contains all structs used in the Integrated Liquidity Market contract suite
+
+/////////////////////
+/// LOOP STRATEGY ///
+/////////////////////
+
+/// @dev contains all data relating to the collateral ratio
+struct CollateralRatio {
+    /// @dev target (ideal) value of the collateral ratio
+    uint256 target;
+    /// @dev mininimum value of the collateral ratio below which strategy will rebalance
+    uint256 minForRebalance;
+    /// @dev maximum value of the collateral ratio above which strategy will rebalance
+    uint256 maxForRebalance;
+    /// @dev minimum value of the collateral ratio, above which rebalance for withdrawing action is not needed
+    uint256 minForWithdrawRebalance;
+    /// @dev maximum value of the collateral ratio, below which rebalance for depositing action is not needed
+    uint256 maxForDepositRebalance;
+}
+
+/// @dev contains assets addresses that strategy is using
+struct StrategyAssets {
+    /// @dev wrapped address of underlying asset of the leverage strategy (asset that users are providing)
+    IERC20 underlying;
+    /// @dev wrapped adddress of collateralized asset of leverage strategy
+    /// @dev this can be different from underlying in cases when we need to wrap
+    /// @dev the underlying token to be able to supply it to the lending pool
+    IERC20 collateral;
+    /// @dev wrapped address of borrowed asset of leverage strategy
+    IERC20 debt;
+}
+
+/// @dev conatins address of the lending pool and configuration
+struct LendingPool {
+    /// @dev address of the lending pool
+    IPool pool;
+    /// @dev interest rate mode used on loan
+    uint256 interestRateMode;
+}
+
+/// @dev contains all data pertaining to the current position state of the strategy
+struct LoanState {
+    /// @dev collateral value in underlying (USD)
+    uint256 collateralUSD;
+    /// @dev debt value in underlying (USD)
+    uint256 debtUSD;
+    /// @dev max amount of collateralAsset which can be withdrawn based on maxLTV to
+    /// avoid health of loan ratio entering liquidation zone
+    uint256 maxWithdrawAmount;
+}
+
+/////////////////////
+///    SWAPPER    ///
+/////////////////////
+
+/// @dev struc to encapsulate a single swap step for a given swap route
+struct Step {
+    /// @dev from address of token to swap from
+    IERC20 from;
+    /// @dev to address of token to swap to
+    IERC20 to;
+    /// @dev cast address of swap adapter
+    ISwapAdapter adapter;
+}
diff -ruN ../src/src/vendor/aerodrome/IPool.sol src/vendor/aerodrome/IPool.sol
--- ../src/src/vendor/aerodrome/IPool.sol	1970-01-01 02:00:00
+++ src/vendor/aerodrome/IPool.sol	2024-02-13 01:00:56
@@ -0,0 +1,218 @@
+// SPDX-License-Identifier: MIT
+
+pragma solidity ^0.8.21;
+
+interface IPool {
+    error DepositsNotEqual();
+    error BelowMinimumK();
+    error FactoryAlreadySet();
+    error InsufficientLiquidity();
+    error InsufficientLiquidityMinted();
+    error InsufficientLiquidityBurned();
+    error InsufficientOutputAmount();
+    error InsufficientInputAmount();
+    error IsPaused();
+    error InvalidTo();
+    error K();
+    error NotEmergencyCouncil();
+
+    event Fees(address indexed sender, uint256 amount0, uint256 amount1);
+    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
+    event Burn(
+        address indexed sender,
+        address indexed to,
+        uint256 amount0,
+        uint256 amount1
+    );
+    event Swap(
+        address indexed sender,
+        address indexed to,
+        uint256 amount0In,
+        uint256 amount1In,
+        uint256 amount0Out,
+        uint256 amount1Out
+    );
+    event Sync(uint256 reserve0, uint256 reserve1);
+    event Claim(
+        address indexed sender,
+        address indexed recipient,
+        uint256 amount0,
+        uint256 amount1
+    );
+
+    // Struct to capture time period obervations every 30 minutes, used for local oracles
+    struct Observation {
+        uint256 timestamp;
+        uint256 reserve0Cumulative;
+        uint256 reserve1Cumulative;
+    }
+
+    /// @notice Returns the decimal (dec), reserves (r), stable (st), and tokens (t) of token0 and token1
+    function metadata()
+        external
+        view
+        returns (
+            uint256 dec0,
+            uint256 dec1,
+            uint256 r0,
+            uint256 r1,
+            bool st,
+            address t0,
+            address t1
+        );
+
+    /// @notice Claim accumulated but unclaimed fees (claimable0 and claimable1)
+    function claimFees() external returns (uint256, uint256);
+
+    /// @notice Returns [token0, token1]
+    function tokens() external view returns (address, address);
+
+    /// @notice Address of token in the pool with the lower address value
+    function token0() external view returns (address);
+
+    /// @notice Address of token in the poool with the higher address value
+    function token1() external view returns (address);
+
+    /// @notice Address of linked PoolFees.sol
+    function poolFees() external view returns (address);
+
+    /// @notice Address of PoolFactory that created this contract
+    function factory() external view returns (address);
+
+    /// @notice Capture oracle reading every 30 minutes (1800 seconds)
+    function periodSize() external view returns (uint256);
+
+    /// @notice Amount of token0 in pool
+    function reserve0() external view returns (uint256);
+
+    /// @notice Amount of token1 in pool
+    function reserve1() external view returns (uint256);
+
+    /// @notice Timestamp of last update to pool
+    function blockTimestampLast() external view returns (uint256);
+
+    /// @notice Cumulative of reserve0 factoring in time elapsed
+    function reserve0CumulativeLast() external view returns (uint256);
+
+    /// @notice Cumulative of reserve1 factoring in time elapsed
+    function reserve1CumulativeLast() external view returns (uint256);
+
+    /// @notice Accumulated fees of token0 (global)
+    function index0() external view returns (uint256);
+
+    /// @notice Accumulated fees of token1 (global)
+    function index1() external view returns (uint256);
+
+    /// @notice Get an LP's relative index0 to index0
+    function supplyIndex0(address) external view returns (uint256);
+
+    /// @notice Get an LP's relative index1 to index1
+    function supplyIndex1(address) external view returns (uint256);
+
+    /// @notice Amount of unclaimed, but claimable tokens from fees of token0 for an LP
+    function claimable0(address) external view returns (uint256);
+
+    /// @notice Amount of unclaimed, but claimable tokens from fees of token1 for an LP
+    function claimable1(address) external view returns (uint256);
+
+    /// @notice Returns the value of K in the Pool, based on its reserves.
+    function getK() external returns (uint256);
+
+    /// @notice Set pool name
+    ///         Only callable by Voter.emergencyCouncil()
+    /// @param __name String of new name
+    function setName(string calldata __name) external;
+
+    /// @notice Set pool symbol
+    ///         Only callable by Voter.emergencyCouncil()
+    /// @param __symbol String of new symbol
+    function setSymbol(string calldata __symbol) external;
+
+    /// @notice Get the number of observations recorded
+    function observationLength() external view returns (uint256);
+
+    /// @notice Get the value of the most recent observation
+    function lastObservation() external view returns (Observation memory);
+
+    /// @notice True if pool is stable, false if volatile
+    function stable() external view returns (bool);
+
+    /// @notice Produces the cumulative price using counterfactuals to save gas and avoid a call to sync.
+    function currentCumulativePrices()
+        external
+        view
+        returns (
+            uint256 reserve0Cumulative,
+            uint256 reserve1Cumulative,
+            uint256 blockTimestamp
+        );
+
+    /// @notice Provides twap price with user configured granularity, up to the full window size
+    /// @param tokenIn .
+    /// @param amountIn .
+    /// @param granularity .
+    /// @return amountOut .
+    function quote(address tokenIn, uint256 amountIn, uint256 granularity)
+        external
+        view
+        returns (uint256 amountOut);
+
+    /// @notice Returns a memory set of TWAP prices
+    ///         Same as calling sample(tokenIn, amountIn, points, 1)
+    /// @param tokenIn .
+    /// @param amountIn .
+    /// @param points Number of points to return
+    /// @return Array of TWAP prices
+    function prices(address tokenIn, uint256 amountIn, uint256 points)
+        external
+        view
+        returns (uint256[] memory);
+
+    /// @notice Same as prices with with an additional window argument.
+    ///         Window = 2 means 2 * 30min (or 1 hr) between observations
+    /// @param tokenIn .
+    /// @param amountIn .
+    /// @param points .
+    /// @param window .
+    /// @return Array of TWAP prices
+    function sample(
+        address tokenIn,
+        uint256 amountIn,
+        uint256 points,
+        uint256 window
+    ) external view returns (uint256[] memory);
+
+    /// @notice This low-level function should be called from a contract which performs important safety checks
+    /// @param amount0Out   Amount of token0 to send to `to`
+    /// @param amount1Out   Amount of token1 to send to `to`
+    /// @param to           Address to recieve the swapped output
+    /// @param data         Additional calldata for flashloans
+    function swap(
+        uint256 amount0Out,
+        uint256 amount1Out,
+        address to,
+        bytes calldata data
+    ) external;
+
+    /// @notice Update reserves and, on the first call per block, price accumulators
+    /// @return _reserve0 .
+    /// @return _reserve1 .
+    /// @return _blockTimestampLast .
+    function getReserves()
+        external
+        view
+        returns (
+            uint256 _reserve0,
+            uint256 _reserve1,
+            uint256 _blockTimestampLast
+        );
+
+    /// @notice Get the amount of tokenOut given the amount of tokenIn
+    /// @param amountIn Amount of token in
+    /// @param tokenIn  Address of token
+    /// @return Amount out
+    function getAmountOut(uint256 amountIn, address tokenIn)
+        external
+        view
+        returns (uint256);
+}
diff -ruN ../src/src/vendor/aerodrome/IPoolFactory.sol src/vendor/aerodrome/IPoolFactory.sol
--- ../src/src/vendor/aerodrome/IPoolFactory.sol	1970-01-01 02:00:00
+++ src/vendor/aerodrome/IPoolFactory.sol	2024-02-13 01:00:56
@@ -0,0 +1,39 @@
+// SPDX-License-Identifier: MIT
+
+pragma solidity ^0.8.21;
+
+interface IPoolFactory {
+    /// @notice returns the number of pools created from this factory
+    function allPoolsLength() external view returns (uint256);
+
+    /// @notice Is a valid pool created by this factory.
+    /// @param .
+    function isPool(address pool) external view returns (bool);
+
+    /// @notice Return address of pool created by this factory
+    /// @param tokenA .
+    /// @param tokenB .
+    /// @param stable True if stable, false if volatile
+    function getPool(address tokenA, address tokenB, bool stable)
+        external
+        view
+        returns (address);
+
+    /// @notice Support for v3-style pools which wraps around getPool(tokenA,tokenB,stable)
+    /// @dev fee is converted to stable boolean.
+    /// @param tokenA .
+    /// @param tokenB .
+    /// @param fee  1 if stable, 0 if volatile, else returns address(0)
+    function getPool(address tokenA, address tokenB, uint24 fee)
+        external
+        view
+        returns (address);
+
+    /// @notice Returns fee for a pool, as custom fees are possible.
+    function getFee(address _pool, bool _stable)
+        external
+        view
+        returns (uint256);
+
+    function isPaused() external view returns (bool);
+}
diff -ruN ../src/src/vendor/aerodrome/IRouter.sol src/vendor/aerodrome/IRouter.sol
--- ../src/src/vendor/aerodrome/IRouter.sol	1970-01-01 02:00:00
+++ src/vendor/aerodrome/IRouter.sol	2024-02-13 01:00:56
@@ -0,0 +1,112 @@
+// SPDX-License-Identifier: MIT
+
+pragma solidity ^0.8.21;
+
+interface IRouter {
+    struct Route {
+        address from;
+        address to;
+        bool stable;
+        address factory;
+    }
+
+    /// @notice Address of FactoryRegistry.sol
+    function factoryRegistry() external view returns (address);
+
+    /// @notice Address of Protocol PoolFactory.sol
+    function defaultFactory() external view returns (address);
+
+    /// @notice Calculate the address of a pool by its' factory.
+    ///         Used by all Router functions containing a `Route[]` or `_factory` argument.
+    ///         Reverts if _factory is not approved by the FactoryRegistry
+    /// @dev Returns a randomly generated address for a nonexistent pool
+    /// @param tokenA   Address of token to query
+    /// @param tokenB   Address of token to query
+    /// @param stable   True if pool is stable, false if volatile
+    /// @param _factory Address of factory which created the pool
+    function poolFor(
+        address tokenA,
+        address tokenB,
+        bool stable,
+        address _factory
+    ) external view returns (address pool);
+
+    /// @notice Fetch and sort the reserves for a pool
+    /// @param tokenA       .
+    /// @param tokenB       .
+    /// @param stable       True if pool is stable, false if volatile
+    /// @param _factory     Address of PoolFactory for tokenA and tokenB
+    /// @return reserveA    Amount of reserves of the sorted token A
+    /// @return reserveB    Amount of reserves of the sorted token B
+    function getReserves(
+        address tokenA,
+        address tokenB,
+        bool stable,
+        address _factory
+    ) external view returns (uint256 reserveA, uint256 reserveB);
+
+    /// @notice Perform chained getAmountOut calculations on any number of pools
+    function getAmountsOut(uint256 amountIn, Route[] memory routes)
+        external
+        view
+        returns (uint256[] memory amounts);
+
+    // **** SWAP ****
+
+    /// @notice Swap one token for another
+    /// @param amountIn     Amount of token in
+    /// @param amountOutMin Minimum amount of desired token received
+    /// @param routes       Array of trade routes used in the swap
+    /// @param to           Recipient of the tokens received
+    /// @param deadline     Deadline to receive tokens
+    /// @return amounts     Array of amounts returned per route
+    function swapExactTokensForTokens(
+        uint256 amountIn,
+        uint256 amountOutMin,
+        Route[] calldata routes,
+        address to,
+        uint256 deadline
+    ) external returns (uint256[] memory amounts);
+
+    /// @notice Swap ETH for a token
+    /// @param amountOutMin Minimum amount of desired token received
+    /// @param routes       Array of trade routes used in the swap
+    /// @param to           Recipient of the tokens received
+    /// @param deadline     Deadline to receive tokens
+    /// @return amounts     Array of amounts returned per route
+    function swapExactETHForTokens(
+        uint256 amountOutMin,
+        Route[] calldata routes,
+        address to,
+        uint256 deadline
+    ) external payable returns (uint256[] memory amounts);
+
+    /// @notice Swap a token for WETH (returned as ETH)
+    /// @param amountIn     Amount of token in
+    /// @param amountOutMin Minimum amount of desired ETH
+    /// @param routes       Array of trade routes used in the swap
+    /// @param to           Recipient of the tokens received
+    /// @param deadline     Deadline to receive tokens
+    /// @return amounts     Array of amounts returned per route
+    function swapExactTokensForETH(
+        uint256 amountIn,
+        uint256 amountOutMin,
+        Route[] calldata routes,
+        address to,
+        uint256 deadline
+    ) external returns (uint256[] memory amounts);
+
+    /// @notice Used by zapper to determine appropriate ratio of A to B to deposit liquidity. Assumes stable pool.
+    /// @dev Returns stable liquidity ratio of B to (A + B).
+    ///      E.g. if ratio is 0.4, it means there is more of A than there is of B.
+    ///      Therefore you should deposit more of token A than B.
+    /// @param tokenA   tokenA of stable pool you are zapping into.
+    /// @param tokenB   tokenB of stable pool you are zapping into.
+    /// @param factory  Factory that created stable pool.
+    /// @return ratio   Ratio of token0 to token1 required to deposit into zap.
+    function quoteStableLiquidityRatio(
+        address tokenA,
+        address tokenB,
+        address factory
+    ) external view returns (uint256 ratio);
+}
diff -ruN ../src/storage/AerodromeAdapterStorage.sol storage/AerodromeAdapterStorage.sol
--- ../src/storage/AerodromeAdapterStorage.sol	2024-02-01 16:35:01
+++ storage/AerodromeAdapterStorage.sol	1970-01-01 02:00:00
@@ -1,31 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { IRouter } from "../vendor/aerodrome/IRouter.sol";
-
-library AerodromeAdapterStorage {
-    /// @dev struct containing all state for the AerodromeAdapter contract
-    /// @custom:storage-location erc7201:seamless.contracts.storage.AerodromeAdapter
-    struct Layout {
-        mapping(IERC20 from => mapping(IERC20 to => IRouter.Route[] routes))
-            swapRoutes;
-        mapping(IERC20 from => mapping(IERC20 to => bool isStable)) isPoolStable;
-        mapping(address pair => address factory) pairFactory;
-        address router;
-        address poolFactory;
-    }
-
-    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.AerodromeAdapter")) - 1)) & ~bytes32(uint256(0xff));
-    bytes32 internal constant STORAGE_SLOT =
-        0xe20fadfe51c05810cf8049153a6d3327f8bd31f8cadde6b0efd76ce5573f2600;
-
-    function layout() internal pure returns (Layout storage l) {
-        bytes32 slot = STORAGE_SLOT;
-        assembly {
-            l.slot := slot
-        }
-    }
-}
diff -ruN ../src/storage/LoopStrategyStorage.sol storage/LoopStrategyStorage.sol
--- ../src/storage/LoopStrategyStorage.sol	2024-02-01 16:35:01
+++ storage/LoopStrategyStorage.sol	1970-01-01 02:00:00
@@ -1,53 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import {
-    CollateralRatio,
-    StrategyAssets,
-    LendingPool
-} from "../types/DataTypes.sol";
-import { IPoolAddressesProvider } from
-    "@aave/contracts/interfaces/IPoolAddressesProvider.sol";
-import { IPool } from "@aave/contracts/interfaces/IPool.sol";
-import { IPriceOracleGetter } from
-    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
-import { ISwapper } from "../interfaces/ISwapper.sol";
-
-library LoopStrategyStorage {
-    /// @dev struct containing all state for the LoopStrategy contract
-    /// @custom:storage-location erc7201:seamless.contracts.storage.LoopStrategy
-    struct Layout {
-        /// @dev struct encapsulating collateral and borrow asset addresses
-        StrategyAssets assets;
-        /// @dev struct encapsulating min/max bounds and target values for the collateral ratio
-        CollateralRatio collateralRatioTargets;
-        /// @dev error margin on specific target collateral ratio passed in function calls
-        uint256 ratioMargin;
-        /// @dev acceptable error margin on usd values - a value from 0 - ONE_USD
-        uint256 usdMargin;
-        /// @dev pool address provider for the Seamles Protocol lending pools
-        IPoolAddressesProvider poolAddressProvider;
-        /// @dev struct encapsulating address of the lending pool and configuration (interest rate mode)
-        LendingPool lendingPool;
-        /// @dev price oracle address
-        IPriceOracleGetter oracle;
-        /// @dev swapper address
-        ISwapper swapper;
-        /// @dev maximum amount of loop iterations when rebalancing
-        uint16 maxIterations;
-        /// @dev maximum amount total assets (total equity) of the strategy
-        uint256 assetsCap;
-    }
-
-    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.LoopStrategy")) - 1)) & ~bytes32(uint256(0xff));
-    bytes32 internal constant STORAGE_SLOT =
-        0x324C4071AA3926AF75895CE4C01A62A23C8476ED82CD28BA23ABB8C0F6634B00;
-
-    function layout() internal pure returns (Layout storage l) {
-        bytes32 slot = STORAGE_SLOT;
-        assembly {
-            l.slot := slot
-        }
-    }
-}
diff -ruN ../src/storage/SwapAdapterBaseStorage.sol storage/SwapAdapterBaseStorage.sol
--- ../src/storage/SwapAdapterBaseStorage.sol	2024-02-01 16:35:01
+++ storage/SwapAdapterBaseStorage.sol	1970-01-01 02:00:00
@@ -1,22 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-library SwapAdapterBaseStorage {
-    /// @dev struct containing all state for the SwapAdapterBase contract
-    /// @custom:storage-location erc7201:seamless.contracts.storage.SwapAdapterBase
-    struct Layout {
-        address swapper;
-    }
-
-    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.SwapAdapterBase")) - 1)) & ~bytes32(uint256(0xff));
-    bytes32 internal constant STORAGE_SLOT =
-        0xebbcbb6f4bc0510bac5105d82440cb1f3fa3634785f911c43618c35177456000;
-
-    function layout() internal pure returns (Layout storage l) {
-        bytes32 slot = STORAGE_SLOT;
-        assembly {
-            l.slot := slot
-        }
-    }
-}
diff -ruN ../src/storage/SwapperStorage.sol storage/SwapperStorage.sol
--- ../src/storage/SwapperStorage.sol	2024-02-01 16:35:01
+++ storage/SwapperStorage.sol	1970-01-01 02:00:00
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IPriceOracleGetter } from
-    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { Step } from "../types/DataTypes.sol";
-
-library SwapperStorage {
-    /// @dev struct containing all state for the Swapper contract
-    /// @custom:storage-location erc7201:seamless.contracts.storage.Swapper
-    struct Layout {
-        mapping(IERC20 from => mapping(IERC20 to => uint256 offsetUSD))
-            offsetUSD;
-        mapping(IERC20 from => mapping(IERC20 to => Step[] steps)) route;
-        uint256 offsetDeviationUSD;
-        IPriceOracleGetter oracle;
-    }
-
-    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.Swapper")) - 1)) & ~bytes32(uint256(0xff));
-    bytes32 internal constant STORAGE_SLOT =
-        0xd13913e6f5971fa78083bb454f0bd9d937359fbaf7a5296aa0498a9631cf8b00;
-
-    function layout() internal pure returns (Layout storage l) {
-        bytes32 slot = STORAGE_SLOT;
-        assembly {
-            l.slot := slot
-        }
-    }
-}
diff -ruN ../src/storage/WrappedTokenAdapterStorage.sol storage/WrappedTokenAdapterStorage.sol
--- ../src/storage/WrappedTokenAdapterStorage.sol	2024-02-01 16:35:01
+++ storage/WrappedTokenAdapterStorage.sol	1970-01-01 02:00:00
@@ -1,32 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { IWrappedERC20PermissionedDeposit } from
-    "../interfaces/IWrappedERC20PermissionedDeposit.sol";
-
-library WrappedTokenAdapterStorage {
-    /// @dev struct containing all state for the WrappedTokenAdapter contract
-    /// @custom:storage-location erc7201:seamless.contracts.storage.WrappedTokenAdapter
-    struct Layout {
-        mapping(
-            IERC20 from
-                => mapping(
-                    IERC20 to => IWrappedERC20PermissionedDeposit wrapper
-                )
-            ) wrappers;
-    }
-
-    // keccak256(abi.encode(uint256(keccak256("seamless.contracts.storage.WrappedTokenAdapter")) - 1)) & ~bytes32(uint256(0xff));
-    bytes32 internal constant STORAGE_SLOT =
-        0x25b70c849dde52d8ddadc20d855caa6e4102bdc5328ba5593a0d5c3e9ab8af00;
-
-    function layout() internal pure returns (Layout storage l) {
-        bytes32 slot = STORAGE_SLOT;
-        assembly {
-            l.slot := slot
-        }
-    }
-}
diff -ruN ../src/swap/Swapper.sol swap/Swapper.sol
--- ../src/swap/Swapper.sol	2024-02-01 16:35:01
+++ swap/Swapper.sol	1970-01-01 02:00:00
@@ -1,250 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IPriceOracleGetter } from
-    "@aave/contracts/interfaces/IPriceOracleGetter.sol";
-import { Math } from "@openzeppelin/contracts/utils/math/Math.sol";
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-import { IERC20Metadata } from
-    "@openzeppelin/contracts/interfaces/IERC20Metadata.sol";
-import { SafeERC20 } from
-    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
-
-import { ConversionMath } from "../libraries/math/ConversionMath.sol";
-import { ISwapper } from "../interfaces/ISwapper.sol";
-import { USDWadRayMath } from "../libraries/math/USDWadRayMath.sol";
-import { SwapperStorage as Storage } from "../storage/SwapperStorage.sol";
-import { Step } from "../types/DataTypes.sol";
-import { AccessControlUpgradeable } from
-    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol";
-import { UUPSUpgradeable } from
-    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
-
-/// @title Swapper
-/// @notice Routing contract for swaps across different DEXs
-contract Swapper is ISwapper, AccessControlUpgradeable, UUPSUpgradeable {
-    using USDWadRayMath for uint256;
-
-    /// @dev role which can use the swap function, only given to ILM strategies
-    bytes32 public constant STRATEGY_ROLE = keccak256("STRATEGY_ROLE");
-    /// @dev role which can change routes and offset factor
-    bytes32 public constant MANAGER_ROLE = keccak256("MANAGER_ROLE");
-    /// @dev role which can upgrade the contract
-    bytes32 public constant UPGRADER_ROLE = keccak256("UPGRADER_ROLE");
-
-    constructor() {
-        _disableInitializers();
-    }
-
-    /// @dev initializer function for Swapper contract
-    function Swapper_init(
-        address initialAdmin,
-        IPriceOracleGetter oracle,
-        uint256 offsetDeviationUSD
-    ) external initializer {
-        __AccessControl_init();
-        __UUPSUpgradeable_init();
-        _grantRole(DEFAULT_ADMIN_ROLE, initialAdmin);
-
-        Storage.Layout storage $ = Storage.layout();
-        $.oracle = oracle;
-        $.offsetDeviationUSD = offsetDeviationUSD;
-    }
-
-    /// @inheritdoc UUPSUpgradeable
-    function _authorizeUpgrade(address)
-        internal
-        override
-        onlyRole(UPGRADER_ROLE)
-    { }
-
-    /// @inheritdoc ISwapper
-    function setRoute(IERC20 from, IERC20 to, Step[] calldata steps)
-        external
-        onlyRole(MANAGER_ROLE)
-    {
-        Storage.Layout storage $ = Storage.layout();
-
-        // remove route if it exists
-        if ($.route[from][to].length != 0) {
-            _removeRoute(from, to);
-        }
-
-        for (uint256 i; i < steps.length; ++i) {
-            if (address(steps[i].adapter) == address(0)) {
-                revert InvalidAddress();
-            }
-
-            $.route[from][to].push(steps[i]);
-        }
-
-        emit RouteSet(from, to, steps);
-    }
-
-    /// @inheritdoc ISwapper
-    function removeRoute(IERC20 from, IERC20 to)
-        external
-        onlyRole(MANAGER_ROLE)
-    {
-        _removeRoute(from, to);
-    }
-
-    /// @inheritdoc ISwapper
-    function setOffsetFactor(IERC20 from, IERC20 to, uint256 offsetUSD)
-        external
-        onlyRole(MANAGER_ROLE)
-    {
-        if (offsetUSD == 0 || offsetUSD > USDWadRayMath.USD) {
-            revert USDValueOutsideRange();
-        }
-
-        Storage.layout().offsetUSD[from][to] = offsetUSD;
-
-        emit OffsetFactorSet(from, to, offsetUSD);
-    }
-
-    /// @inheritdoc ISwapper
-    function setOracle(IPriceOracleGetter oracle)
-        external
-        onlyRole(MANAGER_ROLE)
-    {
-        Storage.layout().oracle = oracle;
-
-        emit OracleSet(oracle);
-    }
-
-    /// @inheritdoc ISwapper
-    function setOffsetDeviationUSD(uint256 offsetDeviationUSD)
-        external
-        onlyRole(MANAGER_ROLE)
-    {
-        if (offsetDeviationUSD > USDWadRayMath.USD) {
-            revert USDValueOutsideRange();
-        }
-
-        Storage.layout().offsetDeviationUSD = offsetDeviationUSD;
-
-        emit OffsetDeviationSet(offsetDeviationUSD);
-    }
-
-    /// @inheritdoc ISwapper
-    function swap(
-        IERC20 from,
-        IERC20 to,
-        uint256 fromAmount,
-        address payable beneficiary
-    ) external onlyRole(STRATEGY_ROLE) returns (uint256 toAmount) {
-        Step[] memory steps = Storage.layout().route[from][to];
-
-        uint256 initialAmount = fromAmount;
-
-        from.transferFrom(msg.sender, address(this), fromAmount);
-
-        // execute the swap for each swap-step in the route,
-        // updating `fromAmount` to be the amount received from
-        // each step
-        for (uint256 i; i < steps.length; ++i) {
-            steps[i].from.approve(address(steps[i].adapter), fromAmount);
-
-            // should handle address(0) cases ie for ETH?
-            fromAmount = steps[i].adapter.executeSwap(
-                steps[i].from, steps[i].to, fromAmount, payable(address(this))
-            );
-        }
-
-        // set the received amount as the amount received from the final
-        // step of the route
-        toAmount = fromAmount;
-
-        _enforceSlippageLimit(from, to, initialAmount, toAmount);
-
-        to.transfer(beneficiary, toAmount);
-    }
-
-    /// @inheritdoc ISwapper
-    function getOffsetDeviationUSD()
-        external
-        view
-        returns (uint256 offsetDeviationUSD)
-    {
-        return Storage.layout().offsetDeviationUSD;
-    }
-
-    /// @inheritdoc ISwapper
-    function getOracle() external view returns (IPriceOracleGetter oracle) {
-        return Storage.layout().oracle;
-    }
-
-    /// @inheritdoc ISwapper
-    function getRoute(IERC20 from, IERC20 to)
-        external
-        view
-        returns (Step[] memory steps)
-    {
-        return Storage.layout().route[from][to];
-    }
-
-    /// @inheritdoc ISwapper
-    function offsetFactor(IERC20 from, IERC20 to)
-        external
-        view
-        returns (uint256 offsetUSD)
-    {
-        return Storage.layout().offsetUSD[from][to];
-    }
-
-    /// @notice deletes an existing route
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    function _removeRoute(IERC20 from, IERC20 to) internal {
-        delete Storage.layout().route[from][to];
-
-        emit RouteRemoved(from, to);
-    }
-
-    /// @notice enforces the maximum slippage allowed for a given swap
-    /// @param from address of starting token
-    /// @param to address of ending token
-    /// @param fromAmount amount being swapped
-    /// @param toAmount amount received
-    function _enforceSlippageLimit(
-        IERC20 from,
-        IERC20 to,
-        uint256 fromAmount,
-        uint256 toAmount
-    ) internal view {
-        Storage.Layout storage $ = Storage.layout();
-        IPriceOracleGetter oracle = $.oracle;
-
-        // convert to/from amount to dollars
-        uint256 fromAmountUSD = ConversionMath.convertAssetToUSD(
-            fromAmount,
-            oracle.getAssetPrice(address(from)),
-            IERC20Metadata(address(from)).decimals()
-        );
-        uint256 toAmountUSD = ConversionMath.convertAssetToUSD(
-            toAmount,
-            oracle.getAssetPrice(address(to)),
-            IERC20Metadata(address(to)).decimals()
-        );
-
-        uint256 offsetUSD = $.offsetUSD[from][to];
-        uint256 maxDeviationUSD =
-            offsetUSD.usdMul($.offsetDeviationUSD).usdDiv(USDWadRayMath.USD);
-
-        // ensure these amounts do not differ by more than given slippage
-        uint256 maxSlippageUSD = fromAmountUSD.usdMul(
-            offsetUSD + maxDeviationUSD
-        ).usdDiv(USDWadRayMath.USD);
-        
-        // for the very low amounts allow 1 wei of slippage
-        if (maxSlippageUSD == 0) {
-            maxSlippageUSD = 1;
-        }
-
-        if (fromAmountUSD - maxSlippageUSD > toAmountUSD) {
-            revert MaxSlippageExceeded();
-        }
-    }
-}
\ No newline at end of file
diff -ruN ../src/swap/adapter/AerodromeAdapter.sol swap/adapter/AerodromeAdapter.sol
--- ../src/swap/adapter/AerodromeAdapter.sol	2024-02-01 16:35:01
+++ swap/adapter/AerodromeAdapter.sol	1970-01-01 02:00:00
@@ -1,169 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { SwapAdapterBase } from "./SwapAdapterBase.sol";
-import { IAerodromeAdapter } from "../../interfaces/IAerodromeAdapter.sol";
-import { ISwapAdapter } from "../../interfaces/ISwapAdapter.sol";
-import { AerodromeAdapterStorage as Storage } from
-    "../../storage/AerodromeAdapterStorage.sol";
-import { SwapAdapterBaseStorage as BaseStorage } from
-    "../../storage/SwapAdapterBaseStorage.sol";
-import { IPoolFactory } from "../../vendor/aerodrome/IPoolFactory.sol";
-import { IRouter } from "../../vendor/aerodrome/IRouter.sol";
-
-/// @title AerodromeAdapter
-/// @notice Adapter contract for executing swaps on aerodrome
-contract AerodromeAdapter is SwapAdapterBase, IAerodromeAdapter {
-    /// @inheritdoc IAerodromeAdapter
-    function AerodromeAdapter__Init(
-        address owner,
-        address router,
-        address factory,
-        address swapper
-    ) external initializer {
-        __Ownable_init(owner);
-
-        Storage.Layout storage $ = Storage.layout();
-        $.router = router;
-        $.poolFactory = factory;
-
-        BaseStorage.layout().swapper = swapper;
-    }
-
-    /// @inheritdoc ISwapAdapter
-    function executeSwap(
-        IERC20 from,
-        IERC20 to,
-        uint256 fromAmount,
-        address payable beneficiary
-    ) external onlySwapper returns (uint256 toAmount) {
-        return _executeSwap(from, to, fromAmount, beneficiary);
-    }
-
-    /// @inheritdoc IAerodromeAdapter
-    function setIsPoolStable(IERC20 from, IERC20 to, bool status)
-        external
-        onlyOwner
-    {
-        Storage.layout().isPoolStable[from][to] = status;
-
-        emit IsPoolStableSet(from, to, status);
-    }
-
-    /// @inheritdoc IAerodromeAdapter
-    function setPoolFactory(address factory) external onlyOwner {
-        Storage.layout().poolFactory = factory;
-
-        emit PoolFactorySet(factory);
-    }
-
-    /// @inheritdoc IAerodromeAdapter
-    function setRouter(address router) external onlyOwner {
-        Storage.layout().router = router;
-
-        emit RouterSet(router);
-    }
-
-    /// @inheritdoc IAerodromeAdapter
-    function setRoutes(IERC20 from, IERC20 to, IRouter.Route[] memory routes)
-        external
-        onlyOwner
-    {
-        Storage.Layout storage $ = Storage.layout();
-
-        if ($.swapRoutes[from][to].length != 0) {
-            _removeRoutes(from, to);
-        }
-
-        for (uint256 i; i < routes.length; ++i) {
-            $.swapRoutes[from][to].push(routes[i]);
-        }
-
-        emit RoutesSet(from, to, routes);
-    }
-
-    /// @inheritdoc IAerodromeAdapter
-    function removeRoutes(IERC20 from, IERC20 to) external onlyOwner {
-        _removeRoutes(from, to);
-    }
-
-    /// @inheritdoc ISwapAdapter
-    function setSwapper(address swapper) external onlyOwner {
-        _setSwapper(swapper);
-    }
-
-    /// @inheritdoc ISwapAdapter
-    function getSwapper() external view returns (address swapper) {
-        return _getSwapper();
-    }
-
-    /// @inheritdoc IAerodromeAdapter
-    function getIsPoolStable(IERC20 from, IERC20 to)
-        external
-        view
-        returns (bool status)
-    {
-        return Storage.layout().isPoolStable[from][to];
-    }
-
-    /// @inheritdoc IAerodromeAdapter
-    function getPoolFactory() external view returns (address factory) {
-        return Storage.layout().poolFactory;
-    }
-
-    //// @inheritdoc IAerodromeAdapter
-    function getRouter() external view returns (address router) {
-        return Storage.layout().router;
-    }
-
-    //// @inheritdoc IAerodromeAdapter
-    function getSwapRoutes(IERC20 from, IERC20 to)
-        external
-        view
-        returns (IRouter.Route[] memory routes)
-    {
-        return Storage.layout().swapRoutes[from][to];
-    }
-
-    /// @notice deletes existing routes for a given swap
-    /// @param from address of token route ends with
-    /// @param to address of token route starts with
-    function _removeRoutes(IERC20 from, IERC20 to) internal {
-        delete Storage.layout().swapRoutes[from][to];
-
-        emit RoutesRemoved(from, to);
-    }
-
-    /// @notice swaps a given amount of a token to another token, sending the final amount to the beneficiary
-    /// @dev overridden internal _executeSwap function from SwapAdapterBase contract
-    /// @param from address of token to swap from
-    /// @param to address of token to swap to
-    /// @param fromAmount amount of from token to swap
-    /// @param beneficiary receiver of final to token amount
-    /// @return toAmount amount of to token returned from swapping
-    function _executeSwap(
-        IERC20 from,
-        IERC20 to,
-        uint256 fromAmount,
-        address payable beneficiary
-    ) internal override returns (uint256 toAmount) {
-        Storage.Layout storage $ = Storage.layout();
-
-        from.transferFrom(msg.sender, address(this), fromAmount);
-
-        from.approve($.router, fromAmount);
-
-        uint256[] memory toAmounts = IRouter($.router).swapExactTokensForTokens(
-            fromAmount,
-            0,
-            $.swapRoutes[from][to],
-            beneficiary,
-            block.timestamp + 10
-        );
-
-        toAmount = toAmounts[toAmounts.length - 1];
-    }
-}
diff -ruN ../src/swap/adapter/SwapAdapterBase.sol swap/adapter/SwapAdapterBase.sol
--- ../src/swap/adapter/SwapAdapterBase.sol	2024-02-01 16:35:01
+++ swap/adapter/SwapAdapterBase.sol	1970-01-01 02:00:00
@@ -1,54 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import {
-    Ownable2StepUpgradeable,
-    OwnableUpgradeable
-} from "@openzeppelin/contracts-upgradeable/access/Ownable2StepUpgradeable.sol";
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { ISwapAdapter } from "../../interfaces/ISwapAdapter.sol";
-import { SwapAdapterBaseStorage as Storage } from
-    "../../storage/SwapAdapterBaseStorage.sol";
-
-/// @title SwapAdapterBase
-/// @notice Base adapter contract for all swap adapters
-/// @dev should be inherited and overridden by all SwapAdapter implementations
-abstract contract SwapAdapterBase is Ownable2StepUpgradeable, ISwapAdapter {
-    modifier onlySwapper() {
-        if (Storage.layout().swapper != msg.sender) {
-            revert NotSwapper();
-        }
-        _;
-    }
-
-    /// @notice swaps a given amount of a token to another token, sending the final amount to the beneficiary
-    /// @param from address of token to swap from
-    /// @param to address of token to swap to
-    /// @param fromAmount amount of from token to swap
-    /// @param beneficiary receiver of final to token amount
-    /// @return toAmount amount of to token returned from swapping
-    function _executeSwap(
-        IERC20 from,
-        IERC20 to,
-        uint256 fromAmount,
-        address payable beneficiary
-    ) internal virtual returns (uint256 toAmount) {
-        // override with adapter specific swap logic
-    }
-
-    /// @notice returns the address of Swapper contract
-    /// @return swapper address of Swapper contract
-    function _getSwapper() internal view virtual returns (address swapper) {
-        return Storage.layout().swapper;
-    }
-
-    /// @notice sets the address of the Swapper contract
-    /// @param swapper address of Swapper contract
-    function _setSwapper(address swapper) internal virtual {
-        Storage.layout().swapper = swapper;
-
-        emit SwapperSet(swapper);
-    }
-}
diff -ruN ../src/swap/adapter/WrappedTokenAdapter.sol swap/adapter/WrappedTokenAdapter.sol
--- ../src/swap/adapter/WrappedTokenAdapter.sol	2024-02-01 16:35:01
+++ swap/adapter/WrappedTokenAdapter.sol	1970-01-01 02:00:00
@@ -1,122 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { SwapAdapterBase } from "./SwapAdapterBase.sol";
-import { ISwapAdapter } from "../../interfaces/ISwapAdapter.sol";
-import { WrappedTokenAdapterStorage as Storage } from
-    "../../storage/WrappedTokenAdapterStorage.sol";
-import { SwapAdapterBaseStorage as BaseStorage } from
-    "../../storage/SwapAdapterBaseStorage.sol";
-import { IWrappedERC20PermissionedDeposit } from
-    "../../interfaces/IWrappedERC20PermissionedDeposit.sol";
-import { IWrappedTokenAdapter } from "../../interfaces/IWrappedTokenAdapter.sol";
-
-/// @title WrappedTokenAdapter
-/// @notice Adapter contract for executing swaps on aerodrome
-contract WrappedTokenAdapter is SwapAdapterBase, IWrappedTokenAdapter {
-    /// @notice emitted when the wrapper contract for a given WrappedToken is set
-    /// @param from token to perform wrapping/unwrapping on
-    /// @param to token which will be received after wrapping/unwrapping
-    /// @param wrapper WrappedERC20PermissionedDeposit contract
-    event WrapperSet(
-        IERC20 from, IERC20 to, IWrappedERC20PermissionedDeposit wrapper
-    );
-
-    /// @notice emitted when the wrapper contract for a given WrappedToken is removed
-    /// @param from token to perform wrapping/unwrapping on
-    /// @param to token which will be received after wrapping/unwrapping
-    event WrapperRemoved(IERC20 from, IERC20 to);
-
-    /// @inheritdoc IWrappedTokenAdapter
-    function WrappedTokenAdapter__Init(address owner, address swapper)
-        external
-        initializer
-    {
-        __Ownable_init(owner);
-        BaseStorage.layout().swapper = swapper;
-    }
-
-    /// @inheritdoc ISwapAdapter
-    function executeSwap(
-        IERC20 from,
-        IERC20 to,
-        uint256 fromAmount,
-        address payable beneficiary
-    ) external onlySwapper returns (uint256 toAmount) {
-        Storage.Layout storage $ = Storage.layout();
-
-        from.transferFrom(msg.sender, address(this), fromAmount);
-
-        IWrappedERC20PermissionedDeposit wrapper = $.wrappers[from][to];
-
-        from.approve(address(wrapper), fromAmount);
-
-        if (address(wrapper.underlying()) == address(to)) {
-            wrapper.withdraw(fromAmount);
-        } else {
-            wrapper.deposit(fromAmount);
-        }
-
-        to.transfer(address(beneficiary), fromAmount);
-
-        // should always be 1:1 ratio
-        return fromAmount;
-    }
-
-    /// @inheritdoc ISwapAdapter
-    function setSwapper(address swapper) external onlyOwner {
-        _setSwapper(swapper);
-    }
-
-    /// @inheritdoc IWrappedTokenAdapter
-    function setWrapper(
-        IERC20 from,
-        IERC20 to,
-        IWrappedERC20PermissionedDeposit wrapper
-    ) external onlyOwner {
-        Storage.Layout storage $ = Storage.layout();
-
-        if (address($.wrappers[from][to]) != address(0)) {
-            _removeWrapper(from, to);
-        }
-
-        $.wrappers[from][to] = wrapper;
-        $.wrappers[to][from] = wrapper;
-
-        emit WrapperSet(from, to, wrapper);
-        emit WrapperSet(to, from, wrapper);
-    }
-
-    /// @inheritdoc IWrappedTokenAdapter
-    function removeWrapper(IERC20 from, IERC20 to) external onlyOwner {
-        _removeWrapper(from, to);
-    }
-
-    /// @inheritdoc IWrappedTokenAdapter
-    function getWrapper(IERC20 from, IERC20 to)
-        external
-        view
-        returns (IWrappedERC20PermissionedDeposit wrapper)
-    {
-        return Storage.layout().wrappers[from][to];
-    }
-
-    /// @inheritdoc ISwapAdapter
-    function getSwapper() external view returns (address swapper) {
-        return _getSwapper();
-    }
-
-    /// @notice removes a previously set wrapper for a given from/to token pair
-    /// @param from token to wrap/unwrap
-    /// @param to token received after wrapping/unwrapping
-    function _removeWrapper(IERC20 from, IERC20 to) internal {
-        delete Storage.layout().wrappers[from][to];
-        delete Storage.layout().wrappers[to][from];
-
-        emit WrapperRemoved(from, to);
-        emit WrapperRemoved(to, from);
-    }
-}
diff -ruN ../src/tokens/WrappedCbETH.sol tokens/WrappedCbETH.sol
--- ../src/tokens/WrappedCbETH.sol	2024-02-01 16:35:01
+++ tokens/WrappedCbETH.sol	1970-01-01 02:00:00
@@ -1,80 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import {
-    Ownable,
-    Ownable2Step
-} from "@openzeppelin/contracts/access/Ownable2Step.sol";
-import { ERC20, IERC20 } from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
-import { SafeERC20 } from
-    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
-
-import { IWrappedERC20PermissionedDeposit } from
-    "../interfaces/IWrappedERC20PermissionedDeposit.sol";
-
-/// @title WrappedCbETH
-/// @notice contract used to wrap underlying ERC20 token and mints the same amount of a wrapped token.
-/// @notice this contract will be used to mainly to wrap cbETH and use it as a collateral in the lending pool
-/// @notice but only strategies contracts will be able to get wrapped token it and borrow against it.
-contract WrappedCbETH is
-    IWrappedERC20PermissionedDeposit,
-    ERC20,
-    Ownable2Step
-{
-    /// @notice address of the underlying token which is wrapped
-    IERC20 public immutable underlying;
-
-    /// @notice map shows if address has pemission to wrap tokens
-    mapping(address => bool) public depositor;
-
-    modifier onlyDepositors() {
-        if (!depositor[msg.sender]) {
-            revert NotDepositor(msg.sender);
-        }
-        _;
-    }
-
-    constructor(
-        string memory _name,
-        string memory _symbol,
-        IERC20 _underlyingToken,
-        address _initialOwner
-    ) ERC20(_name, _symbol) Ownable(_initialOwner) {
-        underlying = _underlyingToken;
-    }
-
-    /// @inheritdoc IWrappedERC20PermissionedDeposit
-    function deposit(uint256 amount) external override onlyDepositors {
-        SafeERC20.safeTransferFrom(
-            underlying, msg.sender, address(this), amount
-        );
-        _mint(msg.sender, amount);
-        emit Deposit(msg.sender, amount);
-    }
-
-    /// @inheritdoc IWrappedERC20PermissionedDeposit
-    function withdraw(uint256 amount) external override {
-        _burn(msg.sender, amount);
-        SafeERC20.safeTransfer(underlying, msg.sender, amount);
-        emit Withdraw(msg.sender, amount);
-    }
-
-    /// @inheritdoc IWrappedERC20PermissionedDeposit
-    function setDepositPermission(address account, bool toSet)
-        external
-        override
-        onlyOwner
-    {
-        depositor[account] = toSet;
-        emit SetDepositPermission(account, toSet);
-    }
-
-    /// @inheritdoc IWrappedERC20PermissionedDeposit
-    function recover() external override onlyOwner {
-        uint256 amountSurplus =
-            underlying.balanceOf(address(this)) - totalSupply();
-        SafeERC20.safeTransfer(underlying, msg.sender, amountSurplus);
-        emit RecoverUnderlyingSurplus(msg.sender, amountSurplus);
-    }
-}
diff -ruN ../src/types/DataTypes.sol types/DataTypes.sol
--- ../src/types/DataTypes.sol	2024-02-01 16:35:01
+++ types/DataTypes.sol	1970-01-01 02:00:00
@@ -1,74 +0,0 @@
-// SPDX-License-Identifier: BUSL-1.1
-
-pragma solidity ^0.8.21;
-
-import { IPool } from "@aave/contracts/interfaces/IPool.sol";
-import { IERC20 } from "@openzeppelin/contracts/interfaces/IERC20.sol";
-
-import { ISwapAdapter } from "../interfaces/ISwapAdapter.sol";
-
-/// @title DataTypes
-/// @notice Contains all structs used in the Integrated Liquidity Market contract suite
-
-/////////////////////
-/// LOOP STRATEGY ///
-/////////////////////
-
-/// @dev contains all data relating to the collateral ratio
-struct CollateralRatio {
-    /// @dev target (ideal) value of the collateral ratio
-    uint256 target;
-    /// @dev mininimum value of the collateral ratio below which strategy will rebalance
-    uint256 minForRebalance;
-    /// @dev maximum value of the collateral ratio above which strategy will rebalance
-    uint256 maxForRebalance;
-    /// @dev minimum value of the collateral ratio, above which rebalance for withdrawing action is not needed
-    uint256 minForWithdrawRebalance;
-    /// @dev maximum value of the collateral ratio, below which rebalance for depositing action is not needed
-    uint256 maxForDepositRebalance;
-}
-
-/// @dev contains assets addresses that strategy is using
-struct StrategyAssets {
-    /// @dev wrapped address of underlying asset of the leverage strategy (asset that users are providing)
-    IERC20 underlying;
-    /// @dev wrapped adddress of collateralized asset of leverage strategy
-    /// @dev this can be different from underlying in cases when we need to wrap
-    /// @dev the underlying token to be able to supply it to the lending pool
-    IERC20 collateral;
-    /// @dev wrapped address of borrowed asset of leverage strategy
-    IERC20 debt;
-}
-
-/// @dev conatins address of the lending pool and configuration
-struct LendingPool {
-    /// @dev address of the lending pool
-    IPool pool;
-    /// @dev interest rate mode used on loan
-    uint256 interestRateMode;
-}
-
-/// @dev contains all data pertaining to the current position state of the strategy
-struct LoanState {
-    /// @dev collateral value in underlying (USD)
-    uint256 collateralUSD;
-    /// @dev debt value in underlying (USD)
-    uint256 debtUSD;
-    /// @dev max amount of collateralAsset which can be withdrawn based on maxLTV to
-    /// avoid health of loan ratio entering liquidation zone
-    uint256 maxWithdrawAmount;
-}
-
-/////////////////////
-///    SWAPPER    ///
-/////////////////////
-
-/// @dev struc to encapsulate a single swap step for a given swap route
-struct Step {
-    /// @dev from address of token to swap from
-    IERC20 from;
-    /// @dev to address of token to swap to
-    IERC20 to;
-    /// @dev cast address of swap adapter
-    ISwapAdapter adapter;
-}
diff -ruN ../src/vendor/aerodrome/IPool.sol vendor/aerodrome/IPool.sol
--- ../src/vendor/aerodrome/IPool.sol	2024-02-01 16:35:01
+++ vendor/aerodrome/IPool.sol	1970-01-01 02:00:00
@@ -1,218 +0,0 @@
-// SPDX-License-Identifier: MIT
-
-pragma solidity ^0.8.21;
-
-interface IPool {
-    error DepositsNotEqual();
-    error BelowMinimumK();
-    error FactoryAlreadySet();
-    error InsufficientLiquidity();
-    error InsufficientLiquidityMinted();
-    error InsufficientLiquidityBurned();
-    error InsufficientOutputAmount();
-    error InsufficientInputAmount();
-    error IsPaused();
-    error InvalidTo();
-    error K();
-    error NotEmergencyCouncil();
-
-    event Fees(address indexed sender, uint256 amount0, uint256 amount1);
-    event Mint(address indexed sender, uint256 amount0, uint256 amount1);
-    event Burn(
-        address indexed sender,
-        address indexed to,
-        uint256 amount0,
-        uint256 amount1
-    );
-    event Swap(
-        address indexed sender,
-        address indexed to,
-        uint256 amount0In,
-        uint256 amount1In,
-        uint256 amount0Out,
-        uint256 amount1Out
-    );
-    event Sync(uint256 reserve0, uint256 reserve1);
-    event Claim(
-        address indexed sender,
-        address indexed recipient,
-        uint256 amount0,
-        uint256 amount1
-    );
-
-    // Struct to capture time period obervations every 30 minutes, used for local oracles
-    struct Observation {
-        uint256 timestamp;
-        uint256 reserve0Cumulative;
-        uint256 reserve1Cumulative;
-    }
-
-    /// @notice Returns the decimal (dec), reserves (r), stable (st), and tokens (t) of token0 and token1
-    function metadata()
-        external
-        view
-        returns (
-            uint256 dec0,
-            uint256 dec1,
-            uint256 r0,
-            uint256 r1,
-            bool st,
-            address t0,
-            address t1
-        );
-
-    /// @notice Claim accumulated but unclaimed fees (claimable0 and claimable1)
-    function claimFees() external returns (uint256, uint256);
-
-    /// @notice Returns [token0, token1]
-    function tokens() external view returns (address, address);
-
-    /// @notice Address of token in the pool with the lower address value
-    function token0() external view returns (address);
-
-    /// @notice Address of token in the poool with the higher address value
-    function token1() external view returns (address);
-
-    /// @notice Address of linked PoolFees.sol
-    function poolFees() external view returns (address);
-
-    /// @notice Address of PoolFactory that created this contract
-    function factory() external view returns (address);
-
-    /// @notice Capture oracle reading every 30 minutes (1800 seconds)
-    function periodSize() external view returns (uint256);
-
-    /// @notice Amount of token0 in pool
-    function reserve0() external view returns (uint256);
-
-    /// @notice Amount of token1 in pool
-    function reserve1() external view returns (uint256);
-
-    /// @notice Timestamp of last update to pool
-    function blockTimestampLast() external view returns (uint256);
-
-    /// @notice Cumulative of reserve0 factoring in time elapsed
-    function reserve0CumulativeLast() external view returns (uint256);
-
-    /// @notice Cumulative of reserve1 factoring in time elapsed
-    function reserve1CumulativeLast() external view returns (uint256);
-
-    /// @notice Accumulated fees of token0 (global)
-    function index0() external view returns (uint256);
-
-    /// @notice Accumulated fees of token1 (global)
-    function index1() external view returns (uint256);
-
-    /// @notice Get an LP's relative index0 to index0
-    function supplyIndex0(address) external view returns (uint256);
-
-    /// @notice Get an LP's relative index1 to index1
-    function supplyIndex1(address) external view returns (uint256);
-
-    /// @notice Amount of unclaimed, but claimable tokens from fees of token0 for an LP
-    function claimable0(address) external view returns (uint256);
-
-    /// @notice Amount of unclaimed, but claimable tokens from fees of token1 for an LP
-    function claimable1(address) external view returns (uint256);
-
-    /// @notice Returns the value of K in the Pool, based on its reserves.
-    function getK() external returns (uint256);
-
-    /// @notice Set pool name
-    ///         Only callable by Voter.emergencyCouncil()
-    /// @param __name String of new name
-    function setName(string calldata __name) external;
-
-    /// @notice Set pool symbol
-    ///         Only callable by Voter.emergencyCouncil()
-    /// @param __symbol String of new symbol
-    function setSymbol(string calldata __symbol) external;
-
-    /// @notice Get the number of observations recorded
-    function observationLength() external view returns (uint256);
-
-    /// @notice Get the value of the most recent observation
-    function lastObservation() external view returns (Observation memory);
-
-    /// @notice True if pool is stable, false if volatile
-    function stable() external view returns (bool);
-
-    /// @notice Produces the cumulative price using counterfactuals to save gas and avoid a call to sync.
-    function currentCumulativePrices()
-        external
-        view
-        returns (
-            uint256 reserve0Cumulative,
-            uint256 reserve1Cumulative,
-            uint256 blockTimestamp
-        );
-
-    /// @notice Provides twap price with user configured granularity, up to the full window size
-    /// @param tokenIn .
-    /// @param amountIn .
-    /// @param granularity .
-    /// @return amountOut .
-    function quote(address tokenIn, uint256 amountIn, uint256 granularity)
-        external
-        view
-        returns (uint256 amountOut);
-
-    /// @notice Returns a memory set of TWAP prices
-    ///         Same as calling sample(tokenIn, amountIn, points, 1)
-    /// @param tokenIn .
-    /// @param amountIn .
-    /// @param points Number of points to return
-    /// @return Array of TWAP prices
-    function prices(address tokenIn, uint256 amountIn, uint256 points)
-        external
-        view
-        returns (uint256[] memory);
-
-    /// @notice Same as prices with with an additional window argument.
-    ///         Window = 2 means 2 * 30min (or 1 hr) between observations
-    /// @param tokenIn .
-    /// @param amountIn .
-    /// @param points .
-    /// @param window .
-    /// @return Array of TWAP prices
-    function sample(
-        address tokenIn,
-        uint256 amountIn,
-        uint256 points,
-        uint256 window
-    ) external view returns (uint256[] memory);
-
-    /// @notice This low-level function should be called from a contract which performs important safety checks
-    /// @param amount0Out   Amount of token0 to send to `to`
-    /// @param amount1Out   Amount of token1 to send to `to`
-    /// @param to           Address to recieve the swapped output
-    /// @param data         Additional calldata for flashloans
-    function swap(
-        uint256 amount0Out,
-        uint256 amount1Out,
-        address to,
-        bytes calldata data
-    ) external;
-
-    /// @notice Update reserves and, on the first call per block, price accumulators
-    /// @return _reserve0 .
-    /// @return _reserve1 .
-    /// @return _blockTimestampLast .
-    function getReserves()
-        external
-        view
-        returns (
-            uint256 _reserve0,
-            uint256 _reserve1,
-            uint256 _blockTimestampLast
-        );
-
-    /// @notice Get the amount of tokenOut given the amount of tokenIn
-    /// @param amountIn Amount of token in
-    /// @param tokenIn  Address of token
-    /// @return Amount out
-    function getAmountOut(uint256 amountIn, address tokenIn)
-        external
-        view
-        returns (uint256);
-}
diff -ruN ../src/vendor/aerodrome/IPoolFactory.sol vendor/aerodrome/IPoolFactory.sol
--- ../src/vendor/aerodrome/IPoolFactory.sol	2024-02-01 16:35:01
+++ vendor/aerodrome/IPoolFactory.sol	1970-01-01 02:00:00
@@ -1,39 +0,0 @@
-// SPDX-License-Identifier: MIT
-
-pragma solidity ^0.8.21;
-
-interface IPoolFactory {
-    /// @notice returns the number of pools created from this factory
-    function allPoolsLength() external view returns (uint256);
-
-    /// @notice Is a valid pool created by this factory.
-    /// @param .
-    function isPool(address pool) external view returns (bool);
-
-    /// @notice Return address of pool created by this factory
-    /// @param tokenA .
-    /// @param tokenB .
-    /// @param stable True if stable, false if volatile
-    function getPool(address tokenA, address tokenB, bool stable)
-        external
-        view
-        returns (address);
-
-    /// @notice Support for v3-style pools which wraps around getPool(tokenA,tokenB,stable)
-    /// @dev fee is converted to stable boolean.
-    /// @param tokenA .
-    /// @param tokenB .
-    /// @param fee  1 if stable, 0 if volatile, else returns address(0)
-    function getPool(address tokenA, address tokenB, uint24 fee)
-        external
-        view
-        returns (address);
-
-    /// @notice Returns fee for a pool, as custom fees are possible.
-    function getFee(address _pool, bool _stable)
-        external
-        view
-        returns (uint256);
-
-    function isPaused() external view returns (bool);
-}
diff -ruN ../src/vendor/aerodrome/IRouter.sol vendor/aerodrome/IRouter.sol
--- ../src/vendor/aerodrome/IRouter.sol	2024-02-01 16:35:01
+++ vendor/aerodrome/IRouter.sol	1970-01-01 02:00:00
@@ -1,112 +0,0 @@
-// SPDX-License-Identifier: MIT
-
-pragma solidity ^0.8.21;
-
-interface IRouter {
-    struct Route {
-        address from;
-        address to;
-        bool stable;
-        address factory;
-    }
-
-    /// @notice Address of FactoryRegistry.sol
-    function factoryRegistry() external view returns (address);
-
-    /// @notice Address of Protocol PoolFactory.sol
-    function defaultFactory() external view returns (address);
-
-    /// @notice Calculate the address of a pool by its' factory.
-    ///         Used by all Router functions containing a `Route[]` or `_factory` argument.
-    ///         Reverts if _factory is not approved by the FactoryRegistry
-    /// @dev Returns a randomly generated address for a nonexistent pool
-    /// @param tokenA   Address of token to query
-    /// @param tokenB   Address of token to query
-    /// @param stable   True if pool is stable, false if volatile
-    /// @param _factory Address of factory which created the pool
-    function poolFor(
-        address tokenA,
-        address tokenB,
-        bool stable,
-        address _factory
-    ) external view returns (address pool);
-
-    /// @notice Fetch and sort the reserves for a pool
-    /// @param tokenA       .
-    /// @param tokenB       .
-    /// @param stable       True if pool is stable, false if volatile
-    /// @param _factory     Address of PoolFactory for tokenA and tokenB
-    /// @return reserveA    Amount of reserves of the sorted token A
-    /// @return reserveB    Amount of reserves of the sorted token B
-    function getReserves(
-        address tokenA,
-        address tokenB,
-        bool stable,
-        address _factory
-    ) external view returns (uint256 reserveA, uint256 reserveB);
-
-    /// @notice Perform chained getAmountOut calculations on any number of pools
-    function getAmountsOut(uint256 amountIn, Route[] memory routes)
-        external
-        view
-        returns (uint256[] memory amounts);
-
-    // **** SWAP ****
-
-    /// @notice Swap one token for another
-    /// @param amountIn     Amount of token in
-    /// @param amountOutMin Minimum amount of desired token received
-    /// @param routes       Array of trade routes used in the swap
-    /// @param to           Recipient of the tokens received
-    /// @param deadline     Deadline to receive tokens
-    /// @return amounts     Array of amounts returned per route
-    function swapExactTokensForTokens(
-        uint256 amountIn,
-        uint256 amountOutMin,
-        Route[] calldata routes,
-        address to,
-        uint256 deadline
-    ) external returns (uint256[] memory amounts);
-
-    /// @notice Swap ETH for a token
-    /// @param amountOutMin Minimum amount of desired token received
-    /// @param routes       Array of trade routes used in the swap
-    /// @param to           Recipient of the tokens received
-    /// @param deadline     Deadline to receive tokens
-    /// @return amounts     Array of amounts returned per route
-    function swapExactETHForTokens(
-        uint256 amountOutMin,
-        Route[] calldata routes,
-        address to,
-        uint256 deadline
-    ) external payable returns (uint256[] memory amounts);
-
-    /// @notice Swap a token for WETH (returned as ETH)
-    /// @param amountIn     Amount of token in
-    /// @param amountOutMin Minimum amount of desired ETH
-    /// @param routes       Array of trade routes used in the swap
-    /// @param to           Recipient of the tokens received
-    /// @param deadline     Deadline to receive tokens
-    /// @return amounts     Array of amounts returned per route
-    function swapExactTokensForETH(
-        uint256 amountIn,
-        uint256 amountOutMin,
-        Route[] calldata routes,
-        address to,
-        uint256 deadline
-    ) external returns (uint256[] memory amounts);
-
-    /// @notice Used by zapper to determine appropriate ratio of A to B to deposit liquidity. Assumes stable pool.
-    /// @dev Returns stable liquidity ratio of B to (A + B).
-    ///      E.g. if ratio is 0.4, it means there is more of A than there is of B.
-    ///      Therefore you should deposit more of token A than B.
-    /// @param tokenA   tokenA of stable pool you are zapping into.
-    /// @param tokenB   tokenB of stable pool you are zapping into.
-    /// @param factory  Factory that created stable pool.
-    /// @return ratio   Ratio of token0 to token1 required to deposit into zap.
-    function quoteStableLiquidityRatio(
-        address tokenA,
-        address tokenB,
-        address factory
-    ) external view returns (uint256 ratio);
-}
